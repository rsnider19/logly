---
phase: 03-chat-screen
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - lib/features/chat/presentation/screens/chat_screen.dart
  - lib/features/chat/presentation/widgets/chat_composer.dart
autonomous: false

must_haves:
  truths:
    - "After sending a question, step progress indicators appear (spinner + label per step, checkmark when done)"
    - "Once all steps complete and streaming begins, steps collapse into a non-expandable summary showing step count and duration"
    - "AI responses render markdown formatting (bold, italic, lists, headers, code blocks) correctly via GptMarkdown"
    - "When a request fails, user sees a friendly inline error message and their original question is restored in the input field"
    - "The chat auto-scrolls to the bottom during streaming but stops if user scrolls up"
  artifacts:
    - path: "lib/features/chat/presentation/screens/chat_screen.dart"
      provides: "Polished chat screen with all builders finalized"
      contains: "ChatScreen"
    - path: "lib/features/chat/presentation/widgets/chat_composer.dart"
      provides: "Composer with error text restoration"
      contains: "ChatComposer"
  key_links:
    - from: "lib/features/chat/presentation/screens/chat_screen.dart"
      to: "lib/features/chat/presentation/providers/chat_ui_provider.dart"
      via: "ref.read(chatUiStateProvider.notifier).lastErrorQuery"
      pattern: "lastErrorQuery"
---

<objective>
Polish the chat screen: refine step progress display, error text restoration in composer, and verify the complete end-to-end flow visually.

Purpose: Plan 02 assembled the core screen but some behaviors need refinement and end-to-end visual verification. This plan polishes the error restoration flow (moving the failed query back to the input), ensures the composer correctly restores text after errors, and runs a visual checkpoint to verify the complete streaming experience.

Output: A polished, production-quality chat screen that meets all Phase 3 success criteria.
</objective>

<execution_context>
@/Users/robsnider/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robsnider/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-chat-screen/03-CONTEXT.md
@.planning/phases/03-chat-screen/03-RESEARCH.md
@.planning/phases/03-chat-screen/03-01-SUMMARY.md
@.planning/phases/03-chat-screen/03-02-SUMMARY.md

Key files to read before implementing:
@lib/features/chat/presentation/screens/chat_screen.dart -- Chat screen from Plan 02
@lib/features/chat/presentation/widgets/chat_composer.dart -- Composer from Plan 02
@lib/features/chat/presentation/providers/chat_ui_provider.dart -- Bridge provider from Plan 01
</context>

<tasks>

<task type="auto">
  <name>Task 1: Error text restoration and composer polish</name>
  <files>
    lib/features/chat/presentation/widgets/chat_composer.dart
    lib/features/chat/presentation/screens/chat_screen.dart
  </files>
  <action>
    **Part A: Composer error text restoration**

    Update `ChatComposer` to support dynamic text restoration:

    1. The composer needs to react when `lastErrorQuery` changes (i.e., when an error occurs and the user's text should be restored).
       - Add a `didUpdateWidget` override that checks if `widget.initialText` changed. If so, set `_textController.text = widget.initialText ?? ''` and update `_hasText`.
       - OR: The ChatScreen should watch for error state changes and pass `initialText` to the composer. Since the composer is rebuilt when ChatScreen rebuilds, the `initialText` prop flow should work naturally.
       - Actually, the cleanest approach: In `ChatScreen`, listen for `chatUiStateProvider.notifier.lastErrorQuery` reactively. When it becomes non-null, the composer should receive it. Since the Chat widget uses `composerBuilder` which rebuilds, the prop will flow naturally.

    2. BUT there's a subtlety: the `composerBuilder` creates a new widget each rebuild, which means the `TextEditingController` gets recreated. To fix this:
       - Move the `TextEditingController` to `ChatScreen` (the parent) and pass it to `ChatComposer`.
       - OR: Use a `key` on the composer based on `lastErrorQuery` to force recreation with new initial text.
       - Simplest: Pass `TextEditingController` from parent. The `ChatScreen` `ConsumerStatefulWidget` owns the controller and passes it down.

    3. In `ChatScreen._ChatScreenState`:
       - Create `final _textController = TextEditingController()` in state
       - Dispose it in `dispose()`
       - When error query is detected (listen to stream state error + lastErrorQuery), set `_textController.text = lastErrorQuery`
       - Pass `_textController` to `ChatComposer` instead of `initialText`

    4. Update `ChatComposer` to accept `TextEditingController controller` instead of `initialText`:
       - Remove internal controller creation
       - Use the passed-in controller
       - The `_hasText` tracking still works -- listen to the external controller's changes

    **Part B: Screen refinements**

    5. In `ChatScreen`:
       - Add a `ref.listen` for `chatStreamStateProvider` that detects error transitions:
         ```dart
         ref.listen(chatStreamStateProvider, (prev, next) {
           if (next.status == ChatConnectionStatus.error && prev?.status != ChatConnectionStatus.error) {
             final errorQuery = ref.read(chatUiStateProvider.notifier).lastErrorQuery;
             if (errorQuery != null) {
               _textController.text = errorQuery;
               _textController.selection = TextSelection.fromPosition(
                 TextPosition(offset: errorQuery.length),
               );
             }
           }
         });
         ```
       - This ensures the text controller is updated at the right moment.

    6. Verify step progress display is working in the `_buildTextStreamMessage` builder:
       - The step progress reads from `message.metadata` (populated by the bridge provider)
       - Ensure the collapsed summary format matches: "Processed in N steps (X.Xs)"
       - Ensure step labels use consumer-friendly names (the edge function sends these, so just display them as-is)

    7. Ensure the `_buildChatMessage` wrapper provides enough vertical spacing between messages (8px between messages should look clean).

    8. Run `fvm flutter analyze` and fix any issues.
    9. Run `fvm dart run build_runner build --delete-conflicting-outputs` if any generated code needs updating.
  </action>
  <verify>
    - `fvm flutter analyze` passes clean
    - On error: user's question text appears in the input field
    - Step progress renders correctly in the streaming message
    - Collapsed summary shows after steps complete
    - Message spacing is visually clean
  </verify>
  <done>
    Error text restoration works end-to-end: when a stream fails, the user's original question is restored in the input field. Step progress and collapsed summary display correctly. All message spacing is polished.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Phase 3 chat screen with:
    - Navigation from profile FAB to /chat (pro gate via existing paywall)
    - Flat layout: user messages in cards, AI messages plain with GptMarkdown
    - Step progress indicators (spinner + label while processing, checkmark when done, collapsed summary)
    - Streaming text via TypewriterBuffer + FlyerChatTextStreamMessage
    - Custom composer with send/stop toggle, auto-expanding input
    - Empty state with LoglyAI welcome and 3 suggestion chips
    - Error handling: inline error message, question text restored to input
  </what-built>
  <how-to-verify>
    1. Open the app and navigate to the Profile tab
    2. Tap the LoglyAI FAB -- it should navigate to the chat screen
    3. On empty chat, verify you see the welcome screen with LoglyAI icon and 3 suggestion chips
    4. Tap a suggestion chip (e.g., "What did I do this week?") -- it should send immediately
    5. Watch for step progress indicators (spinners then checkmarks)
    6. When response streams in, verify markdown renders correctly (bold, lists, etc.)
    7. After response completes, verify steps collapse to "Processed in N steps (X.Xs)" summary
    8. Type a new question and send -- verify user message appears as flat card, AI response streams below
    9. While streaming, verify the input is disabled with "Waiting for response..." placeholder
    10. While streaming, verify the stop button (square icon) appears instead of send
    11. Tap stop -- verify streaming stops and partial text is preserved
    12. (If possible to trigger error) Verify error appears inline with friendly message and question is restored to input

    Focus areas:
    - Message layout: user cards vs AI plain (no bubbles)
    - Step progress animation smoothness
    - Markdown rendering quality
    - Composer behavior during streaming
    - Overall feel matches ChatGPT/Claude style
  </how-to-verify>
  <resume-signal>Type "approved" to complete Phase 3, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. `fvm flutter analyze` -- zero errors, zero warnings
2. Full end-to-end flow works: navigate -> empty state -> send question -> see steps -> see streaming response -> see completed message
3. Error recovery: failed question restored to input, error shown inline
4. Stop/cancel: streaming stops, partial text preserved
5. Visual quality meets ChatGPT/Claude-inspired flat layout standard
</verification>

<success_criteria>
- All Phase 3 success criteria from ROADMAP.md are met:
  1. Tapping LoglyAI button navigates to chat screen
  2. Non-pro users blocked (paywall shown)
  3. Step progress indicators work (spinner -> checkmark -> collapsed summary)
  4. AI responses render markdown correctly
  5. Errors show friendly message with retry (text restoration in input)
- Visual quality approved by user
</success_criteria>

<output>
After completion, create `.planning/phases/03-chat-screen/03-03-SUMMARY.md`
</output>
