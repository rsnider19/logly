---
phase: 03-chat-screen
plan: 04
type: execute
wave: 1
depends_on: ["03-03"]
files_modified:
  - lib/features/chat/presentation/screens/chat_screen.dart
  - lib/features/chat/application/typewriter_buffer.dart
  - lib/features/chat/presentation/providers/chat_ui_provider.dart
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "After all steps complete and text finishes streaming, step indicators collapse into 'Processed in N steps (X.Xs)' summary"
    - "AI response text appears smoothly token-by-token without visual choppiness"
    - "User messages are right-aligned while keeping text left-aligned inside the card"
    - "After an error occurs, the original question text is automatically restored in the composer"
  artifacts:
    - path: "lib/features/chat/presentation/screens/chat_screen.dart"
      provides: "Fixed text message builder, right-aligned user messages, error listener fix"
      contains: "_buildTextMessage, _buildChatMessage"
    - path: "lib/features/chat/application/typewriter_buffer.dart"
      provides: "Batched character emissions for smoother animation"
      contains: "TypewriterBuffer"
    - path: "lib/features/chat/presentation/providers/chat_ui_provider.dart"
      provides: "lastErrorQuery exposed via ChatUiState for deterministic read ordering"
      contains: "ChatUiState"
  key_links:
    - from: "lib/features/chat/presentation/screens/chat_screen.dart"
      to: "lib/features/chat/presentation/providers/chat_ui_provider.dart"
      via: "ref.listen on chatUiStateProvider for error query restoration"
      pattern: "ref\\.listen\\(chatUiStateProvider"
---

<objective>
Fix 4 diagnosed UAT gaps: collapsed step summary disappearing, choppy streaming animation, user message alignment, and error text restoration race condition.

Purpose: UAT identified 4 issues preventing Phase 3 completion. This plan addresses each with targeted fixes: render step summary in completed TextMessage builder, batch typewriter emissions for smoother animation, right-align user message cards, and fix the race condition in error query restoration.

Output: All 4 UAT gaps closed, chat screen ready for re-verification.
</objective>

<execution_context>
@/Users/robsnider/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robsnider/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-chat-screen/03-UAT.md

Key files to read before implementing:
@lib/features/chat/presentation/screens/chat_screen.dart -- Current implementation with gaps
@lib/features/chat/application/typewriter_buffer.dart -- Current 5ms/char timing
@lib/features/chat/presentation/providers/chat_ui_provider.dart -- _lastErrorQuery storage
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix collapsed step summary in completed AI messages</name>
  <files>lib/features/chat/presentation/screens/chat_screen.dart</files>
  <action>
    **Problem:** `_buildTextMessage` (lines 143-147) only renders GptMarkdown for AI messages, ignoring the metadata that contains step summary data. When a TextStreamMessage converts to TextMessage on completion, the step progress disappears.

    **Fix:** Update `_buildTextMessage` to render step progress BEFORE the markdown content for AI messages.

    In `_buildTextMessage`, for the AI message case (when `!isSentByMe`), change from:

    ```dart
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: GptMarkdown(message.text, style: theme.textTheme.bodyLarge),
    );
    ```

    To:

    ```dart
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildStepProgress(message.metadata, theme),
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 4),
          child: GptMarkdown(message.text, style: theme.textTheme.bodyLarge),
        ),
      ],
    );
    ```

    This reuses the existing `_buildStepProgress` helper which already handles:
    - Empty metadata (returns SizedBox.shrink)
    - Collapsed state (renders "Processed in N steps (X.Xs)" summary)
    - Non-collapsed state (renders step list with checkmarks)

    The metadata from `_finalizeMessage` in the UI provider includes:
    - `steps`: List of step names
    - `stepsCollapsed`: true
    - `stepCount`: number of steps
    - `stepDurationMs`: duration in milliseconds

    **Verification:** After an AI response completes, the collapsed summary line should appear above the response text.
  </action>
  <verify>
    - Send a question and wait for response to complete
    - Verify "Processed in N steps (X.Xs)" summary appears above the AI response text
    - Verify summary persists after scrolling away and back
  </verify>
  <done>Completed AI messages display the collapsed step summary above the response text.</done>
</task>

<task type="auto">
  <name>Task 2: Smooth streaming animation with batched emissions</name>
  <files>lib/features/chat/application/typewriter_buffer.dart</files>
  <action>
    **Problem:** TypewriterBuffer emits one character every 5ms (200 chars/sec = 200 state updates/sec). Each emission triggers a UI rebuild. At 200 rebuilds/sec, Flutter exceeds its 60fps frame budget, causing visual choppiness.

    **Fix:** Batch character emissions to emit 3-5 characters per tick, reducing updates to ~40-60/sec.

    Change the timer callback in `_ensureTimerRunning` from emitting 1 character to emitting up to 5 characters per tick:

    Current code (lines 81-89):
    ```dart
    final bufferStr = _pendingBuffer.toString();
    final char = bufferStr[0];
    _pendingBuffer
      ..clear()
      ..write(bufferStr.substring(1));
    _emittedBuffer.write(char);
    if (!_controller.isClosed) {
      _controller.add(_emittedBuffer.toString());
    }
    ```

    New code:
    ```dart
    final bufferStr = _pendingBuffer.toString();
    // Emit up to 5 characters per tick for smoother animation
    final chunkSize = bufferStr.length.clamp(1, 5);
    final chunk = bufferStr.substring(0, chunkSize);
    _pendingBuffer
      ..clear()
      ..write(bufferStr.substring(chunkSize));
    _emittedBuffer.write(chunk);
    if (!_controller.isClosed) {
      _controller.add(_emittedBuffer.toString());
    }
    ```

    Also increase the base interval from 5ms to 16ms (matches 60fps frame timing):
    - Change `normalInterval` default from `Duration(milliseconds: 5)` to `Duration(milliseconds: 16)`
    - Keep `drainInterval` at 1ms but also batch 5 chars (fast drain is fine since it's brief)

    **Result:** ~60 updates/sec * 5 chars = ~300 chars/sec effective speed, smoother than before.

    **Alternative if still choppy:** Increase to 8-10 chars per tick or 25ms interval.
  </action>
  <verify>
    - Send a question and observe the streaming text
    - Text should appear fluidly without visible stuttering or jerkiness
    - Typing effect should still be visible (not instant dump)
    - `fvm flutter analyze` passes
  </verify>
  <done>Streaming animation appears smooth and fluid without visible choppiness.</done>
</task>

<task type="auto">
  <name>Task 3: Right-align user message cards</name>
  <files>lib/features/chat/presentation/screens/chat_screen.dart</files>
  <action>
    **Problem:** `_buildChatMessage` (lines 109-115) wraps all messages in identical Padding without using `isSentByMe` to position user messages on the right.

    **Fix:** Use an `Align` widget to right-align user messages while keeping AI messages left-aligned.

    Change `_buildChatMessage` from:

    ```dart
    return SizeTransition(
      sizeFactor: animation,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
        child: child,
      ),
    );
    ```

    To:

    ```dart
    return SizeTransition(
      sizeFactor: animation,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
        child: Align(
          alignment: isSentByMe ? Alignment.centerRight : Alignment.centerLeft,
          child: child,
        ),
      ),
    );
    ```

    **Note:** The user's card already has left-aligned text inside (via `Text(message.text)`), so the card will be right-aligned but text inside remains left-aligned as requested.

    For better visual appearance, also constrain user message width so it doesn't stretch full-width:

    ```dart
    return SizeTransition(
      sizeFactor: animation,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
        child: Align(
          alignment: isSentByMe ? Alignment.centerRight : Alignment.centerLeft,
          child: isSentByMe
              ? ConstrainedBox(
                  constraints: BoxConstraints(
                    maxWidth: MediaQuery.of(context).size.width * 0.85,
                  ),
                  child: child,
                )
              : child,
        ),
      ),
    );
    ```

    This constrains user messages to 85% screen width max while AI messages remain full-width.
  </action>
  <verify>
    - Send a message and observe the user message card
    - User message card should be right-aligned (pushed to the right side)
    - Text inside the card should still be left-aligned
    - AI messages should remain left-aligned, full-width
  </verify>
  <done>User messages appear right-aligned with left-aligned text inside; AI messages remain left-aligned.</done>
</task>

<task type="auto">
  <name>Task 4: Fix error text restoration race condition</name>
  <files>
    lib/features/chat/presentation/providers/chat_ui_provider.dart
    lib/features/chat/presentation/screens/chat_screen.dart
  </files>
  <action>
    **Problem:** ChatScreen's `ref.listen` on `chatStreamStateProvider` detects error status and reads `lastErrorQuery` from `chatUiStateProvider.notifier`. But `ChatUiStateNotifier._handleError` (which sets `_lastErrorQuery`) runs in a separate listener with no guaranteed ordering. The screen may read `null` before the notifier writes the value.

    **Fix:** Expose `lastErrorQuery` as part of the notifier's observable state, or listen to `chatUiStateProvider` (the controller) for a custom error signal.

    **Approach A (Simpler - recommended):** Change ChatScreen to listen to `chatUiStateProvider` combined with a dedicated error state signal, rather than racing between two listeners.

    Since `chatUiStateProvider` returns `InMemoryChatController`, we need a different approach. The cleanest fix:

    1. In `ChatUiStateNotifier`, after `_handleError` completes (after `_lastErrorQuery` is set), manually notify by calling a state refresh or using a separate state provider.

    2. **Better approach:** Have `ChatScreen` listen to `chatUiStateProvider.notifier` for the error state, reading `lastErrorQuery` in a microtask or frame callback to ensure ordering.

    **Simplest fix:** In `ChatScreen`, defer the read of `lastErrorQuery` by one frame using `WidgetsBinding.instance.addPostFrameCallback`:

    In `chat_screen.dart`, change the error listener from:

    ```dart
    ref.listen(chatStreamStateProvider, (prev, next) {
      if (next.status == ChatConnectionStatus.error &&
          prev?.status != ChatConnectionStatus.error) {
        final errorQuery = ref.read(chatUiStateProvider.notifier).lastErrorQuery;
        if (errorQuery != null) {
          _textController.text = errorQuery;
          _textController.selection = TextSelection.fromPosition(
            TextPosition(offset: errorQuery.length),
          );
        }
      }
    });
    ```

    To:

    ```dart
    ref.listen(chatStreamStateProvider, (prev, next) {
      if (next.status == ChatConnectionStatus.error &&
          prev?.status != ChatConnectionStatus.error) {
        // Defer to next frame to ensure _handleError has set lastErrorQuery
        WidgetsBinding.instance.addPostFrameCallback((_) {
          final errorQuery = ref.read(chatUiStateProvider.notifier).lastErrorQuery;
          if (errorQuery != null && mounted) {
            _textController.text = errorQuery;
            _textController.selection = TextSelection.fromPosition(
              TextPosition(offset: errorQuery.length),
            );
          }
        });
      }
    });
    ```

    This ensures the notifier's `_handleError` listener executes first (in the same microtask queue), and the screen reads the value in the next frame callback.

    **Alternative (more robust):** Create a separate `lastErrorQueryProvider` that `_handleError` updates, and have ChatScreen listen to that provider directly. But the frame callback approach is simpler and sufficient.
  </action>
  <verify>
    - Trigger an error (e.g., airplane mode, invalid request)
    - After error message appears, verify the original question text is restored in the composer input
    - Cursor should be at the end of the restored text
    - `fvm flutter analyze` passes
  </verify>
  <done>After an error, the user's original question is restored in the composer input field.</done>
</task>

</tasks>

<verification>
1. `fvm flutter analyze` -- zero errors, zero warnings
2. Send a question, wait for completion -- collapsed step summary "Processed in N steps (X.Xs)" appears
3. Send another question, observe streaming -- text appears smoothly without choppiness
4. User messages are right-aligned, AI messages left-aligned
5. Trigger an error (airplane mode or force quit server) -- question text restored to input
</verification>

<success_criteria>
- All 4 UAT gaps closed:
  1. Collapsed step summary visible for completed AI messages (Test 6)
  2. Streaming animation is smooth and fluid (Test 7)
  3. User messages right-aligned, text left-aligned inside (Test 9)
  4. Error text restoration works reliably (Test 14)
- Ready for UAT re-verification
</success_criteria>

<output>
After completion, update `.planning/phases/03-chat-screen/03-04-SUMMARY.md` and re-run UAT.
</output>
