---
phase: 05-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260204000000_create_chat_telemetry_log.sql
  - supabase/functions/chat/telemetry.ts
  - supabase/snippets/observability_reports.sql
autonomous: true

must_haves:
  truths:
    - "A chat_telemetry_log table exists with denormalized columns for all metrics"
    - "Telemetry records can be inserted via service role without user access"
    - "Example report queries are documented and runnable in Supabase dashboard"
  artifacts:
    - path: "supabase/migrations/20260204000000_create_chat_telemetry_log.sql"
      provides: "Telemetry table schema with indexes and RLS"
      contains: "CREATE TABLE public.chat_telemetry_log"
    - path: "supabase/functions/chat/telemetry.ts"
      provides: "TelemetryRecord interface and persistTelemetry function"
      exports: ["TelemetryRecord", "persistTelemetry"]
    - path: "supabase/snippets/observability_reports.sql"
      provides: "Example SQL queries for cost, latency, and error reporting"
      contains: "token cost"
  key_links:
    - from: "supabase/functions/chat/telemetry.ts"
      to: "supabase/migrations/20260204000000_create_chat_telemetry_log.sql"
      via: "table name reference"
      pattern: "chat_telemetry_log"
---

<objective>
Create the database schema and telemetry persistence module for Phase 5 observability.

Purpose: Establish the data storage foundation for capturing metrics from every AI chat interaction, enabling cost and quality monitoring.

Output:
- `chat_telemetry_log` table migration with all columns defined in CONTEXT.md
- `telemetry.ts` module with TelemetryRecord interface and fire-and-forget persistence
- `observability_reports.sql` with example queries matching success criteria (token cost, latency, error rates)
</objective>

<execution_context>
@/Users/robsnider/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robsnider/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-observability/CONTEXT.md
@.planning/phases/05-observability/05-RESEARCH.md
@supabase/functions/chat/persistence.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat_telemetry_log migration</name>
  <files>supabase/migrations/20260204000000_create_chat_telemetry_log.sql</files>
  <action>
Create migration file with the denormalized telemetry table schema.

**Table columns (per CONTEXT.md decisions):**

Identifiers:
- `log_id` uuid PRIMARY KEY DEFAULT gen_random_uuid()
- `user_id` uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
- `conversation_id` uuid REFERENCES public.chat_conversations(conversation_id) ON DELETE SET NULL
- `response_id` text (OpenAI response ID)

Timestamps:
- `created_at` timestamptz NOT NULL DEFAULT now()

Content captured:
- `user_question` text NOT NULL
- `ai_response` text (NULL if error before response)
- `generated_sql` text (NULL if off-topic or error)
- `sql_fingerprint` text (md5 hash computed by trigger)
- `result_row_count` integer
- `follow_up_suggestions` jsonb (array of strings)

Error tracking:
- `error_type` text ('sql_generation', 'sql_validation', 'sql_execution', 'response_generation', 'unexpected')
- `error_message` text
- `failed_step` text ('understanding', 'looking_up', 'response')

Flags:
- `is_off_topic` boolean NOT NULL DEFAULT false

Model tracking:
- `sql_model` text
- `response_model` text

Timing (all integer milliseconds, NULLABLE for partial failures):
- `nl_to_sql_duration_ms` integer
- `sql_execution_duration_ms` integer
- `response_generation_duration_ms` integer
- `ttfb_ms` integer

Token tracking (NULLABLE for partial failures):
- `sql_input_tokens` integer
- `sql_output_tokens` integer
- `sql_cached_tokens` integer
- `response_input_tokens` integer
- `response_output_tokens` integer
- `response_cached_tokens` integer

**Indexes (per CONTEXT.md):**
- `idx_chat_telemetry_created_at` ON (created_at DESC)
- `idx_chat_telemetry_user_id` ON (user_id, created_at DESC)
- `idx_chat_telemetry_error` ON (error_type) WHERE error_type IS NOT NULL
- `idx_chat_telemetry_fingerprint` ON (sql_fingerprint) WHERE sql_fingerprint IS NOT NULL

**Trigger for fingerprint:** Create a BEFORE INSERT trigger that computes sql_fingerprint as md5(lower(regexp_replace(generated_sql, '\s+', ' ', 'g'))) when generated_sql is NOT NULL.

**RLS:** Enable RLS with NO user-facing policies. Only service_role can access.
  </action>
  <verify>
Run: `fvm dart run supabase migrations list` to verify migration appears.
Check SQL syntax is valid by reviewing file contents.
  </verify>
  <done>
Migration file exists with all columns, indexes, trigger for fingerprint, and RLS enabled with service-role-only access.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create telemetry persistence module</name>
  <files>supabase/functions/chat/telemetry.ts</files>
  <action>
Create the telemetry module following the pattern in persistence.ts.

**TelemetryRecord interface** with all fields matching table columns (camelCase):
- userId, conversationId, responseId
- userQuestion, aiResponse, generatedSql, resultRowCount, followUpSuggestions
- errorType, errorMessage, failedStep
- isOffTopic
- sqlModel, responseModel
- nlToSqlDurationMs, sqlExecutionDurationMs, responseGenerationDurationMs, ttfbMs
- sqlInputTokens, sqlOutputTokens, sqlCachedTokens
- responseInputTokens, responseOutputTokens, responseCachedTokens

**persistTelemetry function:**
- Uses supabaseAdmin client (same pattern as persistence.ts)
- Maps camelCase interface fields to snake_case column names
- Does NOT compute sql_fingerprint (trigger handles it)
- Wraps in try/catch -- logs errors but never throws (non-fatal)
- Returns Promise<void>

Follow existing persistence.ts patterns for:
- Supabase client initialization
- Error handling with console.error
- Import style
  </action>
  <verify>
Run: `deno check supabase/functions/chat/telemetry.ts` to verify TypeScript compiles.
  </verify>
  <done>
telemetry.ts exports TelemetryRecord interface and persistTelemetry function. Function uses service role, handles errors gracefully, and never throws.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create observability report queries</name>
  <files>supabase/snippets/observability_reports.sql</files>
  <action>
Create SQL file with documented example queries for dashboard reporting.

**Queries to include (per CONTEXT.md report capabilities):**

1. **Total token cost over time range** - Calculate from stored counts using token prices as CTE. Show daily aggregates with input/output/cached tokens and estimated USD cost.

2. **Average latency per step with percentiles** - Show p50, p95, p99 for nl_to_sql, sql_execution, response_generation, and ttfb. Filter to successful requests.

3. **Error rate breakdown** - Count by error_type and failed_step with percentage of total.

4. **Per-user usage and cost** - Show request count, total tokens, error count, off-topic count per user for last 30 days.

5. **Top SQL patterns by fingerprint** - Group by sql_fingerprint, show occurrence count, one example SQL, average execution time, average row count.

6. **Off-topic rate over time** - Daily total requests vs off-topic count with percentage.

7. **Model comparison** - Group by sql_model/response_model to compare latency and token usage.

Each query should have:
- Comment header explaining what it measures
- Reasonable defaults (e.g., last 7 or 30 days)
- Proper NULL handling for partial failures

Note on token prices: Use gpt-4o-mini rates ($0.15/1M input, $0.60/1M output) as CTE. Cached tokens at 50% discount.
  </action>
  <verify>
Review file for SQL syntax correctness and completeness of all 7 query types.
  </verify>
  <done>
observability_reports.sql contains documented queries for token cost, latency percentiles, error breakdown, per-user stats, SQL pattern analysis, off-topic rate, and model comparison.
  </done>
</task>

</tasks>

<verification>
1. Migration file exists at `supabase/migrations/20260204000000_create_chat_telemetry_log.sql`
2. Migration contains CREATE TABLE with all specified columns (count: 27 columns)
3. Migration contains 4 indexes on created_at, user_id, error_type, sql_fingerprint
4. Migration contains trigger for sql_fingerprint computation
5. Migration enables RLS with no user policies
6. `supabase/functions/chat/telemetry.ts` exports TelemetryRecord and persistTelemetry
7. telemetry.ts compiles without errors
8. `supabase/snippets/observability_reports.sql` contains 7 documented queries
</verification>

<success_criteria>
- Database schema matches CONTEXT.md decisions exactly (denormalized, flat columns, separate token columns per step)
- Telemetry persistence function is non-blocking and never throws
- Report queries can calculate total token cost, average latency per step, and error rates (Phase 5 success criteria #4)
</success_criteria>

<output>
After completion, create `.planning/phases/05-observability/05-01-SUMMARY.md`
</output>
