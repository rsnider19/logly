---
phase: 01-edge-function
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - supabase/functions/chat/index.ts
  - supabase/functions/chat/deno.json
autonomous: false

must_haves:
  truths:
    - "Calling POST /functions/v1/chat with a valid JWT and JSON body containing a query returns an SSE stream"
    - "Requests without a valid JWT return 401"
    - "Requests from non-pro users return 403 with premium_required code"
    - "Requests exceeding the rate limit return a friendly 429 message"
    - "Requests with missing or invalid body return 400"
    - "Non-POST methods return 405"
    - "The complete pipeline executes: auth -> subscription check -> rate limit -> NL-to-SQL -> validate -> execute with RLS -> stream response"
  artifacts:
    - path: "supabase/functions/chat/index.ts"
      provides: "Edge function entry point with auth, subscription, rate limit, and pipeline routing"
      exports: []
    - path: "supabase/functions/chat/deno.json"
      provides: "Deno configuration for the chat function"
      contains: "imports"
  key_links:
    - from: "supabase/functions/chat/index.ts"
      to: "supabase/functions/_utils/verifyJwt.ts"
      via: "import AuthMiddleware"
      pattern: "import.*AuthMiddleware.*from.*verifyJwt"
    - from: "supabase/functions/chat/index.ts"
      to: "supabase/functions/_utils/isEntitledTo.ts"
      via: "import isEntitledTo"
      pattern: "import.*isEntitledTo.*from.*isEntitledTo"
    - from: "supabase/functions/chat/index.ts"
      to: "supabase/functions/chat/pipeline.ts"
      via: "import runPipeline"
      pattern: "import.*runPipeline.*from.*pipeline"
    - from: "supabase/functions/chat/index.ts"
      to: "supabase/functions/chat/rateLimit.ts"
      via: "import checkRateLimit"
      pattern: "import.*checkRateLimit.*from.*rateLimit"
---

<objective>
Create the entry point for the `chat` edge function and verify the complete pipeline works end-to-end.

Purpose: This wires together all foundation and pipeline files into a deployable Supabase edge function, and verifies it works via local testing.

Output: A fully functional `chat` edge function that can be served locally and tested with curl.
</objective>

<execution_context>
@/Users/robsnider/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robsnider/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-edge-function/01-CONTEXT.md
@.planning/phases/01-edge-function/01-RESEARCH.md
@.planning/phases/01-edge-function/01-01-SUMMARY.md
@.planning/phases/01-edge-function/01-02-SUMMARY.md

# Source patterns to reference (READ these files before implementing):
@supabase/functions/ai-insights/index.ts
@supabase/functions/ai-insights/deno.json
@supabase/functions/deno.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create entry point and Deno config</name>
  <files>supabase/functions/chat/index.ts, supabase/functions/chat/deno.json</files>
  <action>
Create `supabase/functions/chat/deno.json`:
- Minimal config matching the existing `ai-insights/deno.json` pattern:
  ```json
  {
    "imports": {}
  }
  ```

Create `supabase/functions/chat/index.ts`:
- Reference the existing `supabase/functions/ai-insights/index.ts` for the exact pattern.
- Import `"jsr:@supabase/functions-js/edge-runtime.d.ts"` at the top.
- Import `AuthMiddleware` from `"../_utils/verifyJwt.ts"`.
- Import `isEntitledTo` from `"../_utils/isEntitledTo.ts"`.
- Import `checkRateLimit` from `"./rateLimit.ts"`.
- Import `runPipeline` from `"./pipeline.ts"`.

- Entry point structure (`Deno.serve` with `AuthMiddleware`):

  1. **Method check:** Only accept POST. Return 405 for other methods.

  2. **Auth check:** If `!userId`, return 401 (unlike ai-insights which returns 403 -- the AuthMiddleware already handles 401 for bad JWT, but if userId is somehow null after middleware, return 401).
     ```typescript
     if (!userId) {
       return Response.json({ message: "Unauthorized" }, { status: 401 });
     }
     ```

  3. **Subscription check:** Call `isEntitledTo({ userId, entitlement: "ai-insights" })` (same entitlement name as existing -- the pro subscription covers both features).
     - If not entitled: return 403 with `{ message: "Forbidden", code: "premium_required" }`.

  4. **Rate limit check:** Call `checkRateLimit(userId)`.
     - If not allowed: return 429 with friendly message `{ message: "You've been busy! Give me a moment to catch up. Try again in a few minutes." }`.
     - This is a JSON response (not SSE) because the client hasn't started reading a stream yet.

  5. **Parse body:** Try `req.json()`. Extract `query`, `previousResponseId`, `previousConversionId`.
     - If `!query || typeof query !== "string"`: return 400 with `{ error: "Missing or invalid 'query' field" }`.
     - Catch JSON parse errors: return 400 with `{ error: "Invalid JSON body" }`.

  6. **Log the request:** `console.log(\`[Chat] Request from user ${userId}: "${query}"${previousResponseId ? \` (follow-up)\` : ""}\`)`.

  7. **Run pipeline:** Return `runPipeline({ query, userId, previousResponseId, previousConversionId })`.

- Include a comment block at the bottom with curl examples for local testing (same pattern as ai-insights):
  ```
  /* To invoke locally:
     1. Run `supabase start`
     2. Run `supabase functions serve chat --env-file ./supabase/functions/.env`
     3. First question:
        curl -N --location --request POST 'http://127.0.0.1:54321/functions/v1/chat' \
          --header 'Authorization: Bearer <JWT>' \
          --header 'Content-Type: application/json' \
          --data '{"query":"How many activities did I log this week?"}'
     4. Follow-up:
        curl -N --location --request POST 'http://127.0.0.1:54321/functions/v1/chat' \
          --header 'Authorization: Bearer <JWT>' \
          --header 'Content-Type: application/json' \
          --data '{"query":"What about last month?", "previousResponseId":"resp_...", "previousConversionId":"resp_..."}'
  */
  ```
  </action>
  <verify>
Both files exist and have valid TypeScript syntax:
```bash
deno check supabase/functions/chat/index.ts
```
- `index.ts` imports from `_utils/verifyJwt.ts`, `_utils/isEntitledTo.ts`, `./rateLimit.ts`, `./pipeline.ts`
- `index.ts` has auth -> subscription -> rate limit -> parse -> pipeline flow
- `deno.json` exists with valid JSON
  </verify>
  <done>
- Entry point handles all HTTP method/auth/subscription/rate-limit/body-parsing checks before pipeline
- Non-POST returns 405, missing auth returns 401, non-pro returns 403, rate limited returns 429, bad body returns 400
- Valid requests route to `runPipeline` and return SSE stream
- Deno config exists for the function
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete `chat` edge function with NL-to-SQL pipeline, RLS-enforced query execution, SSE streaming, rate limiting, and security guardrails. All 9 files in supabase/functions/chat/.</what-built>
  <how-to-verify>
1. Ensure Upstash Redis env vars are set in `supabase/functions/.env`:
   ```
   UPSTASH_REDIS_REST_URL=...
   UPSTASH_REDIS_REST_TOKEN=...
   ```

2. Start Supabase locally (if not already running):
   ```bash
   supabase start
   ```

3. Serve the chat function:
   ```bash
   supabase functions serve chat --env-file ./supabase/functions/.env
   ```

4. Test with a valid JWT (replace with your test JWT):
   ```bash
   curl -N --location --request POST 'http://127.0.0.1:54321/functions/v1/chat' \
     --header 'Authorization: Bearer YOUR_JWT' \
     --header 'Content-Type: application/json' \
     --data '{"query":"How many activities did I log this week?"}'
   ```

5. Verify the SSE stream contains:
   - `step` events with status "start" and "complete"
   - `text_delta` events with response text
   - `response_id` event
   - `conversion_id` event
   - `done` event

6. Test error cases:
   - No auth header -> 401
   - Missing query field -> 400
   - Non-POST method -> 405

7. Test a follow-up using the responseId and conversionId from step 5.
  </how-to-verify>
  <resume-signal>Type "approved" if the function works correctly, or describe any issues encountered.</resume-signal>
</task>

</tasks>

<verification>
After both tasks complete:
1. All 9 files exist in `supabase/functions/chat/`:
   - schema.ts, prompts.ts, security.ts, streamHandler.ts (Plan 01)
   - rateLimit.ts, queryExecutor.ts, sqlGenerator.ts, responseGenerator.ts, pipeline.ts (Plan 02)
   - index.ts, deno.json (Plan 03)
2. The function serves locally without errors
3. A natural language question returns an SSE stream with step events and a friendly response
4. Auth, subscription, and rate limit gates work correctly
5. Follow-up questions produce context-aware responses
</verification>

<success_criteria>
- Entry point correctly gates on auth, subscription, rate limit, and body validation
- Complete pipeline executes end-to-end: NL question -> SQL generation -> validation -> RLS execution -> streaming response
- SSE event protocol matches CONTEXT.md decisions exactly
- Function is deployable to Supabase
</success_criteria>

<output>
After completion, create `.planning/phases/01-edge-function/01-03-SUMMARY.md`
</output>
