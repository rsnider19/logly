---
phase: 01-edge-function
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/functions/chat/schema.ts
  - supabase/functions/chat/prompts.ts
  - supabase/functions/chat/security.ts
  - supabase/functions/chat/streamHandler.ts
autonomous: true

must_haves:
  truths:
    - "Schema definition exists with all user-scoped tables and relationships needed for NL-to-SQL"
    - "System prompts instruct the LLM to generate SELECT-only SQL scoped to user data"
    - "SQL validation rejects any query that is not a read-only SELECT"
    - "Input sanitization strips known prompt injection patterns"
    - "SSE stream handler emits the five decided event types: step, text_delta, response_id, error, done"
    - "Step events use start/complete status pairs as decided in CONTEXT.md"
  artifacts:
    - path: "supabase/functions/chat/schema.ts"
      provides: "Compressed database schema constant for system prompt"
      contains: "COMPRESSED_SCHEMA"
    - path: "supabase/functions/chat/prompts.ts"
      provides: "NL-to-SQL system instructions and response personality instructions"
      exports: ["NL_TO_SQL_INSTRUCTIONS", "RESPONSE_INSTRUCTIONS"]
    - path: "supabase/functions/chat/security.ts"
      provides: "SQL validation and input sanitization functions"
      exports: ["validateSqlQuery", "sanitizeUserInput"]
    - path: "supabase/functions/chat/streamHandler.ts"
      provides: "SSE stream creation and event sending utilities"
      exports: ["createProgressStream", "createSSEHeaders"]
  key_links:
    - from: "supabase/functions/chat/prompts.ts"
      to: "supabase/functions/chat/schema.ts"
      via: "import COMPRESSED_SCHEMA"
      pattern: "import.*COMPRESSED_SCHEMA.*from.*schema"
---

<objective>
Create the foundation files for the `chat` edge function: database schema definition, system prompts, SQL security validation, input sanitization, and SSE stream handler.

Purpose: These are the building blocks that the pipeline (Plan 02) and entry point (Plan 03) depend on. They contain no business logic orchestration -- just the schema, prompts, validators, and stream utilities.

Output: Four files in `supabase/functions/chat/` that can be imported by the pipeline.
</objective>

<execution_context>
@/Users/robsnider/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robsnider/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-edge-function/01-CONTEXT.md
@.planning/phases/01-edge-function/01-RESEARCH.md

# Source patterns to reference (READ these files before implementing):
@supabase/functions/ai-insights/schema.ts
@supabase/functions/ai-insights/security.ts
@supabase/functions/ai-insights/streamHandler.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schema and prompts files</name>
  <files>supabase/functions/chat/schema.ts, supabase/functions/chat/prompts.ts</files>
  <action>
Create `supabase/functions/chat/schema.ts`:
- Copy the `COMPRESSED_SCHEMA` constant from `supabase/functions/ai-insights/schema.ts` exactly as-is (same tables, FKs, enums, category codes). The schema is the same database.
- Export only `COMPRESSED_SCHEMA` (do NOT include NL_TO_SQL_INSTRUCTIONS here -- that moves to prompts.ts).

Create `supabase/functions/chat/prompts.ts`:
- Import `COMPRESSED_SCHEMA` from `./schema.ts`.
- Export `NL_TO_SQL_INSTRUCTIONS` constant: Base on the existing one from `ai-insights/schema.ts` but with these changes:
  - Remove the `[user_id: ${userId}]` approach from the instructions -- the new function uses RLS so the LLM does NOT need to filter by user_id. Instead, instruct: "Do NOT include user_id filters. Row-level security handles user scoping automatically."
  - Keep all other rules (SELECT only, minified SQL, cast COUNT to int, fts search, sub_activity ILIKE, category codes, date formatting, Sunday week start, no exposed IDs, conversation history for follow-ups, pace calculation, context search).
  - Add a rule for off-topic detection: "If the user's question is not about their Logly activity data, return JSON with `offTopic: true` and `redirectMessage` containing a friendly redirect. Example: `{ \"offTopic\": true, \"redirectMessage\": \"I can only help with your Logly data! Try asking about your activities or streaks.\" }`. Otherwise return `{ \"offTopic\": false, \"sqlQuery\": \"...\" }`."
  - Add a rule: "Hard limit: queries must not return more than 100 rows. Use aggregation (COUNT, SUM, AVG, GROUP BY) when the user asks about patterns or totals. Add LIMIT 100 as a safety net."
  - Add a health disclaimer rule: "If the query involves health correlations or medical-sounding analysis, include a note in the SQL comment: -- health_disclaimer"
  - Append the `COMPRESSED_SCHEMA` at the end of the instructions string.
  - Use GPT-4o-mini compatible structured output format.

- Export `RESPONSE_INSTRUCTIONS` constant: Based on the existing one from `ai-insights/agent.ts` (the `RESPONSE_INSTRUCTIONS` const) but enhanced with CONTEXT.md personality decisions:
  - Encouraging coach personality -- celebrates wins, motivates, keeps things positive
  - Concise with context -- direct answer plus 1-2 sentences of encouragement or insight
  - Emojis used sparingly for warmth at key moments, not every sentence
  - Markdown formatting: bold key numbers, bullet lists for multiple data points
  - When no data found: acknowledge the gap and gently encourage ("I don't see any runs logged last week. No worries -- want to start tracking them?")
  - Health disclaimer: "If the SQL had a `-- health_disclaimer` comment, include: _This is just a fun look at your data -- not medical advice!_"
  - Keep the existing duration formatting rules.
  - Keep rule about never mentioning SQL, queries, or technical details.
  - Keep rule about not exposing IDs.
  </action>
  <verify>
Both files exist and have valid TypeScript syntax:
```bash
deno check supabase/functions/chat/schema.ts
deno check supabase/functions/chat/prompts.ts
```
`COMPRESSED_SCHEMA` is imported in prompts.ts and embedded in NL_TO_SQL_INSTRUCTIONS.
  </verify>
  <done>
- `schema.ts` exports `COMPRESSED_SCHEMA` with all user-scoped tables
- `prompts.ts` exports `NL_TO_SQL_INSTRUCTIONS` (with off-topic detection, no user_id filtering, 100-row limit, health disclaimer) and `RESPONSE_INSTRUCTIONS` (encouraging coach personality, markdown formatting, health disclaimer)
- `prompts.ts` imports and embeds `COMPRESSED_SCHEMA`
  </done>
</task>

<task type="auto">
  <name>Task 2: Create security validation and SSE stream handler</name>
  <files>supabase/functions/chat/security.ts, supabase/functions/chat/streamHandler.ts</files>
  <action>
Create `supabase/functions/chat/security.ts`:
- Reference `supabase/functions/ai-insights/security.ts` for the base pattern.
- Export `validateSqlQuery(sql: string): ValidationResult` -- same interface as existing (`{ valid: boolean; error?: string }`).
  - Must start with SELECT (case-insensitive after trim).
  - Block dangerous keywords with word-boundary regex: DROP, DELETE, INSERT, UPDATE, ALTER, TRUNCATE, CREATE, GRANT, REVOKE, EXEC, EXECUTE, INTO, COPY, VACUUM, REINDEX, CLUSTER (same list as existing).
  - Block injection patterns: trailing semicolons, multi-statement semicolons, SQL comments (-- and /* */), hex escapes, UNION SELECT (same patterns as existing).
  - Add maximum query length check: 2000 characters.
- Export `sanitizeUserInput(input: string): string` -- this is the prompt injection defense layer (NEW, not in existing security.ts).
  - Strip control characters (Unicode range \x00-\x08, \x0B, \x0C, \x0E-\x1F).
  - Check and strip adversarial patterns from research:
    - `ignore (all )?previous instructions`
    - `ignore (all )?above`
    - `disregard (all )?previous`
    - `forget (all )?instructions`
    - `you are now`
    - `new instructions?:`
    - `system\s*:\s*`
    - `\bprompt\b.*\binjection\b`
    - `act as (a )?different`
    - `override (your )?instructions`
  - Log warnings to console when adversarial patterns detected (for monitoring).
  - Enforce max input length of 500 characters (truncate, don't reject).
  - Return the sanitized string.

Create `supabase/functions/chat/streamHandler.ts`:
- Reference `supabase/functions/ai-insights/streamHandler.ts` for the base pattern (ReadableStream, TextEncoder, buffer, safeEnqueue).
- IMPORTANT: The event protocol is DIFFERENT from ai-insights per CONTEXT.md decisions. Use these event types:
  - `step`: `{ type: "step", name: string, status: "start" | "complete" }` -- NOT "in_progress"/"complete" like ai-insights. Use "start"/"complete" per CONTEXT.md.
  - `text_delta`: `{ type: "text_delta", delta: string }` -- NOT "text" like ai-insights.
  - `response_id`: `{ type: "response_id", responseId: string }`
  - `conversion_id`: `{ type: "conversion_id", conversionId: string }` -- for follow-up SQL context
  - `error`: `{ type: "error", message: string }`
  - `done`: `{ type: "done" }` -- NEW, not in ai-insights. Just a completion signal.
- Export `createProgressStream()` returning an object with methods:
  - `stream` (ReadableStream)
  - `sendStep(name: string, status: "start" | "complete"): void`
  - `sendTextDelta(delta: string): void` -- note the method name matches event type
  - `sendResponseId(responseId: string): void`
  - `sendConversionId(conversionId: string): void`
  - `sendError(message: string): void`
  - `sendDone(): void` -- NEW
  - `close(): void`
- Export `createSSEHeaders(): Headers` -- same as existing (text/event-stream, keep-alive, no-cache, X-Accel-Buffering: no).
- Export TypeScript types for all message interfaces.
- Do NOT export STEP_NAMES or DB_STEP_NAMES here -- step label copy will be defined in the pipeline (Plan 02).
  </action>
  <verify>
Both files exist and have valid TypeScript syntax:
```bash
deno check supabase/functions/chat/security.ts
deno check supabase/functions/chat/streamHandler.ts
```
- `security.ts` exports `validateSqlQuery` and `sanitizeUserInput`
- `streamHandler.ts` exports `createProgressStream` and `createSSEHeaders`
- Stream handler sends `text_delta` (not `text`) and step status uses `start`/`complete` (not `in_progress`/`complete`)
- Stream handler has `sendDone()` method
  </verify>
  <done>
- `security.ts` validates SQL is SELECT-only, blocks dangerous keywords and injection patterns, enforces 2000 char limit
- `security.ts` sanitizes user input by stripping prompt injection patterns, control chars, and enforcing 500 char limit
- `streamHandler.ts` creates SSE streams with the five decided event types (step, text_delta, response_id, error, done) plus conversion_id
- Step events use start/complete status pairs per CONTEXT.md
- All functions are exported and importable
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. All four files exist in `supabase/functions/chat/`
2. `deno check` passes on all files (no type errors)
3. `prompts.ts` imports from `schema.ts` (cross-file dependency works)
4. `security.ts` and `streamHandler.ts` are self-contained (no cross-dependencies)
5. SSE event types match CONTEXT.md decisions exactly
</verification>

<success_criteria>
- Four foundation files created with correct exports
- Schema matches the existing database tables
- Prompts include off-topic detection, no user_id filtering (RLS handles it), 100-row limit, health disclaimer, encouraging coach personality
- SQL validation blocks all dangerous operations
- Input sanitization strips prompt injection patterns
- Stream handler implements the exact SSE protocol from CONTEXT.md (step start/complete, text_delta, response_id, error, done)
</success_criteria>

<output>
After completion, create `.planning/phases/01-edge-function/01-01-SUMMARY.md`
</output>
