---
phase: 04-conversation-discovery
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - supabase/functions/chat/index.ts
  - supabase/functions/chat/persistence.ts
  - supabase/functions/chat/pipeline.ts
  - lib/features/chat/domain/chat_event.dart
  - lib/features/chat/domain/chat_stream_state.dart
  - lib/features/chat/data/chat_conversation_repository.dart
  - lib/features/chat/data/chat_message_repository.dart
autonomous: true

must_haves:
  truths:
    - "Edge function creates conversation on first message"
    - "Edge function saves user and AI messages to Supabase"
    - "Flutter parses conversation_id and follow_up_suggestions from done event"
    - "ChatStreamState holds conversationId and followUpSuggestions"
    - "Flutter repositories can READ conversations and messages (no writes)"
  artifacts:
    - path: "supabase/functions/chat/persistence.ts"
      provides: "Server-side persistence functions"
      contains: "createConversation"
    - path: "lib/features/chat/domain/chat_event.dart"
      provides: "Done event with conversation_id and follow_up_suggestions"
      contains: "conversationId"
    - path: "lib/features/chat/domain/chat_stream_state.dart"
      provides: "conversationId and followUpSuggestions fields"
      contains: "conversationId"
    - path: "lib/features/chat/data/chat_conversation_repository.dart"
      provides: "Read-only Supabase repository for conversations"
      contains: "ChatConversationRepository"
    - path: "lib/features/chat/data/chat_message_repository.dart"
      provides: "Read-only Supabase repository for messages"
      contains: "ChatMessageRepository"
  key_links:
    - from: "supabase/functions/chat/pipeline.ts"
      to: "persistence.ts"
      via: "createConversation and saveMessages calls"
      pattern: "persistence\\."
    - from: "lib/features/chat/data/chat_conversation_repository.dart"
      to: "domain/chat_conversation.dart"
      via: "ChatConversation.fromJson"
      pattern: "ChatConversation\\.fromJson"
---

<objective>
Implement backend-owned persistence in the edge function and create read-only Flutter repositories.

Purpose: The backend (edge function) owns all message persistence per user decision. Flutter client only reads data for display. Edge function creates conversations on first message, saves user messages before processing, and saves AI responses after generation.
Output: Edge function persistence module, SSE events with conversation_id, Flutter read-only repositories.
</objective>

<execution_context>
@/Users/robsnider/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robsnider/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-conversation-discovery/04-CONTEXT.md
@.planning/phases/04-conversation-discovery/04-01-SUMMARY.md
@.planning/phases/04-conversation-discovery/04-02-SUMMARY.md

# Edge function code
@supabase/functions/chat/index.ts
@supabase/functions/chat/pipeline.ts
@supabase/functions/chat/streamHandler.ts

# Domain models from Plan 01
@lib/features/chat/domain/chat_conversation.dart
@lib/features/chat/domain/chat_message.dart

# Existing state
@lib/features/chat/domain/chat_event.dart
@lib/features/chat/domain/chat_stream_state.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create edge function persistence module</name>
  <files>
supabase/functions/chat/persistence.ts
supabase/functions/chat/pipeline.ts
supabase/functions/chat/index.ts
  </files>
  <action>
**Create supabase/functions/chat/persistence.ts:**

```typescript
import { createClient, SupabaseClient } from "npm:@supabase/supabase-js";

/**
 * Persistence module for chat conversations and messages.
 *
 * The edge function (backend) owns all writes to chat tables.
 * Uses service_role key to bypass RLS for writes.
 */

// Use service_role for server-side writes (bypasses RLS)
const supabaseAdmin = createClient(
  Deno.env.get("SUPABASE_URL")!,
  Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!
);

export interface ConversationContext {
  conversationId: string;
  lastResponseId?: string;
  lastConversionId?: string;
}

/**
 * Creates a new conversation or returns existing one.
 *
 * If conversationId is provided in request, returns it.
 * Otherwise creates a new conversation with the first message as title.
 */
export async function getOrCreateConversation(
  userId: string,
  userMessage: string,
  existingConversationId?: string
): Promise<string> {
  // If continuing existing conversation, verify it exists and belongs to user
  if (existingConversationId) {
    const { data: existing } = await supabaseAdmin
      .from("chat_conversations")
      .select("conversation_id")
      .eq("conversation_id", existingConversationId)
      .eq("user_id", userId)
      .single();

    if (existing) {
      return existingConversationId;
    }
    // If not found, fall through to create new
    console.warn(`[Persistence] Conversation ${existingConversationId} not found for user, creating new`);
  }

  // Create new conversation
  const title = userMessage.length > 50
    ? `${userMessage.substring(0, 47)}...`
    : userMessage;

  const { data, error } = await supabaseAdmin
    .from("chat_conversations")
    .insert({
      user_id: userId,
      title,
    })
    .select("conversation_id")
    .single();

  if (error) {
    console.error("[Persistence] Failed to create conversation:", error);
    throw new Error("Failed to create conversation");
  }

  return data.conversation_id;
}

/**
 * Saves the user message to the conversation.
 * Called before processing the request.
 */
export async function saveUserMessage(
  conversationId: string,
  content: string
): Promise<string> {
  const { data, error } = await supabaseAdmin
    .from("chat_messages")
    .insert({
      conversation_id: conversationId,
      role: "user",
      content,
    })
    .select("message_id")
    .single();

  if (error) {
    console.error("[Persistence] Failed to save user message:", error);
    throw new Error("Failed to save user message");
  }

  return data.message_id;
}

/**
 * Saves the AI response message.
 * Called after response generation completes.
 */
export async function saveAssistantMessage(
  conversationId: string,
  content: string,
  metadata?: {
    followUpSuggestions?: string[];
    steps?: string[];
  }
): Promise<string> {
  const { data, error } = await supabaseAdmin
    .from("chat_messages")
    .insert({
      conversation_id: conversationId,
      role: "assistant",
      content,
      metadata: metadata ? {
        follow_up_suggestions: metadata.followUpSuggestions,
        steps: metadata.steps,
      } : null,
    })
    .select("message_id")
    .single();

  if (error) {
    console.error("[Persistence] Failed to save assistant message:", error);
    throw new Error("Failed to save assistant message");
  }

  return data.message_id;
}

/**
 * Updates conversation with latest response/conversion IDs.
 * Called after response generation completes.
 */
export async function updateConversationIds(
  conversationId: string,
  responseId?: string,
  conversionId?: string
): Promise<void> {
  const { error } = await supabaseAdmin
    .from("chat_conversations")
    .update({
      last_response_id: responseId,
      last_conversion_id: conversionId,
      updated_at: new Date().toISOString(),
    })
    .eq("conversation_id", conversationId);

  if (error) {
    console.error("[Persistence] Failed to update conversation IDs:", error);
    // Non-fatal - don't throw
  }
}

/**
 * Gets conversation context (IDs for follow-up chaining).
 */
export async function getConversationContext(
  conversationId: string,
  userId: string
): Promise<ConversationContext | null> {
  const { data, error } = await supabaseAdmin
    .from("chat_conversations")
    .select("conversation_id, last_response_id, last_conversion_id")
    .eq("conversation_id", conversationId)
    .eq("user_id", userId)
    .single();

  if (error || !data) return null;

  return {
    conversationId: data.conversation_id,
    lastResponseId: data.last_response_id,
    lastConversionId: data.last_conversion_id,
  };
}
```

**Update supabase/functions/chat/index.ts:**

Update the request handler to accept optional conversation_id:

1. Add to request body parsing:
```typescript
const { question, conversationId: existingConversationId } = await req.json();
```

2. Update the pipeline call signature (if needed) to pass the existing conversation ID.

**Update supabase/functions/chat/pipeline.ts:**

1. Import persistence functions:
```typescript
import {
  getOrCreateConversation,
  saveUserMessage,
  saveAssistantMessage,
  updateConversationIds,
  getConversationContext,
} from "./persistence.ts";
```

2. At the start of processRequest (or equivalent function), after getting userId:
```typescript
// Get or create conversation
const conversationId = await getOrCreateConversation(
  userId,
  question,
  existingConversationId
);

// Save user message before processing
await saveUserMessage(conversationId, question);

// If continuing conversation, load context for follow-up chaining
let previousResponseId: string | undefined;
let previousConversionId: string | undefined;
if (existingConversationId) {
  const context = await getConversationContext(existingConversationId, userId);
  if (context) {
    previousResponseId = context.lastResponseId;
    previousConversionId = context.lastConversionId;
  }
}
```

3. After response generation completes (after extracting follow-ups, before sendDone):
```typescript
// Save AI response to database
await saveAssistantMessage(
  conversationId,
  fullResponseText.replace(/<!-- FOLLOW_UPS:.*-->/, "").trim(), // Clean content
  {
    followUpSuggestions: followUps.length > 0 ? followUps : undefined,
    steps: completedSteps.length > 0 ? completedSteps : undefined,
  }
);

// Update conversation with latest IDs for follow-up chaining
await updateConversationIds(conversationId, responseId, conversionId);
```

4. Pass conversationId to sendDone (see Task 2 for done event changes).
  </action>
  <verify>Check persistence.ts exists with all functions, verify pipeline.ts imports and calls persistence functions</verify>
  <done>Edge function creates conversations, saves user messages, saves AI responses, updates follow-up IDs</done>
</task>

<task type="auto">
  <name>Task 2: Update done event with conversation_id and parse in Flutter</name>
  <files>
supabase/functions/chat/streamHandler.ts
lib/features/chat/domain/chat_event.dart
lib/features/chat/domain/chat_stream_state.dart
  </files>
  <action>
**Update supabase/functions/chat/streamHandler.ts:**

1. Modify DoneMessage interface to include conversation_id:
```typescript
export interface DoneMessage {
  type: "done";
  conversation_id: string;
  follow_up_suggestions?: string[];
}
```

2. Update sendDone signature:
```typescript
sendDone(conversationId: string, followUpSuggestions?: string[]): void;
```

3. Update implementation:
```typescript
sendDone(conversationId: string, followUpSuggestions?: string[]): void {
  const message: DoneMessage = {
    type: "done",
    conversation_id: conversationId,
  };
  if (followUpSuggestions && followUpSuggestions.length > 0) {
    message.follow_up_suggestions = followUpSuggestions;
  }
  sendMessage(message);
},
```

**Update supabase/functions/chat/pipeline.ts:**

Update the sendDone call to include conversationId:
```typescript
progress.sendDone(conversationId, followUps);
```

**Update lib/features/chat/domain/chat_event.dart:**

Modify the done factory to include conversationId and followUpSuggestions:

```dart
/// Stream completion with conversation context and follow-up suggestions.
@FreezedUnionValue('done')
const factory ChatEvent.done({
  @JsonKey(name: 'conversation_id') required String conversationId,
  @JsonKey(name: 'follow_up_suggestions') @Default([]) List<String> followUpSuggestions,
}) = ChatDoneEvent;
```

Run build_runner to regenerate.

**Update lib/features/chat/domain/chat_stream_state.dart:**

Add conversationId and followUpSuggestions fields:

```dart
/// The conversation ID (set by backend on first message, persists across requests).
String? conversationId,

/// Follow-up question suggestions (populated from done event).
@Default([]) List<String> followUpSuggestions,
```

Add these after the existing ID fields (responseId, conversionId) and before errorMessage.

Run build_runner to regenerate.
  </action>
  <verify>Run `fvm dart run build_runner build --delete-conflicting-outputs` - ChatDoneEvent should have conversationId and followUpSuggestions</verify>
  <done>Done event includes conversation_id and follow_up_suggestions, Flutter state holds both</done>
</task>

<task type="auto">
  <name>Task 3: Create read-only Flutter repositories for conversations and messages</name>
  <files>
lib/features/chat/data/chat_conversation_repository.dart
lib/features/chat/data/chat_message_repository.dart
  </files>
  <action>
**Create lib/features/chat/data/chat_conversation_repository.dart:**

Read-only repository - NO insert/update methods. Backend owns writes.

```dart
import 'package:logly/features/chat/domain/chat_conversation.dart';
import 'package:logly/services/supabase_service.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'chat_conversation_repository.g.dart';

/// Repository for reading chat conversations from Supabase.
///
/// This is a READ-ONLY repository. All writes are handled by the
/// edge function (backend owns persistence).
class ChatConversationRepository {
  ChatConversationRepository(this._supabase);

  final SupabaseService _supabase;

  /// Gets all conversations for the current user, ordered by most recent.
  ///
  /// Used for the conversation history list.
  Future<List<ChatConversation>> getAll({int limit = 50, int offset = 0}) async {
    final response = await _supabase.client
        .from('chat_conversations')
        .select()
        .order('updated_at', ascending: false)
        .range(offset, offset + limit - 1);

    return (response as List<dynamic>)
        .map((json) => ChatConversation.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  /// Gets a conversation by ID.
  Future<ChatConversation?> getById(String conversationId) async {
    final response = await _supabase.client
        .from('chat_conversations')
        .select()
        .eq('conversation_id', conversationId)
        .maybeSingle();

    if (response == null) return null;
    return ChatConversation.fromJson(response);
  }

  /// Deletes a conversation (cascades to messages via FK).
  ///
  /// This is the only write operation allowed from client - user-initiated delete.
  Future<void> delete(String conversationId) async {
    await _supabase.client
        .from('chat_conversations')
        .delete()
        .eq('conversation_id', conversationId);
  }
}

@Riverpod(keepAlive: true)
ChatConversationRepository chatConversationRepository(
  ChatConversationRepositoryRef ref,
) {
  return ChatConversationRepository(ref.watch(supabaseServiceProvider));
}
```

**Create lib/features/chat/data/chat_message_repository.dart:**

Read-only repository - NO insert/update methods.

```dart
import 'package:logly/features/chat/domain/chat_message.dart';
import 'package:logly/services/supabase_service.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'chat_message_repository.g.dart';

/// Repository for reading chat messages from Supabase.
///
/// This is a READ-ONLY repository. All writes are handled by the
/// edge function (backend owns persistence).
class ChatMessageRepository {
  ChatMessageRepository(this._supabase);

  final SupabaseService _supabase;

  /// Gets messages for a conversation, ordered by creation time.
  ///
  /// [limit] defaults to 50 messages for pagination.
  /// [offset] for scroll-up pagination (load older messages).
  Future<List<ChatMessage>> getByConversation(
    String conversationId, {
    int limit = 50,
    int offset = 0,
  }) async {
    final response = await _supabase.client
        .from('chat_messages')
        .select()
        .eq('conversation_id', conversationId)
        .order('created_at', ascending: true)
        .range(offset, offset + limit - 1);

    return (response as List<dynamic>)
        .map((json) => _parseMessage(json as Map<String, dynamic>))
        .toList();
  }

  /// Gets the message count for a conversation.
  ///
  /// Useful for pagination calculations.
  Future<int> getCountByConversation(String conversationId) async {
    final response = await _supabase.client
        .from('chat_messages')
        .select('message_id')
        .eq('conversation_id', conversationId);

    return (response as List<dynamic>).length;
  }

  ChatMessage _parseMessage(Map<String, dynamic> json) {
    // Handle metadata parsing - it comes as JSONB from Supabase
    ChatMessageMetadata? metadata;
    if (json['metadata'] != null) {
      metadata = ChatMessageMetadata.fromJson(json['metadata'] as Map<String, dynamic>);
    }

    return ChatMessage(
      messageId: json['message_id'] as String,
      conversationId: json['conversation_id'] as String,
      role: ChatMessageRole.values.byName(json['role'] as String),
      content: json['content'] as String,
      metadata: metadata,
      createdAt: DateTime.parse(json['created_at'] as String),
    );
  }
}

@Riverpod(keepAlive: true)
ChatMessageRepository chatMessageRepository(
  ChatMessageRepositoryRef ref,
) {
  return ChatMessageRepository(ref.watch(supabaseServiceProvider));
}
```

Run build_runner after creating these files.
  </action>
  <verify>Run `fvm dart run build_runner build --delete-conflicting-outputs` and `fvm flutter analyze` - should pass</verify>
  <done>Read-only repositories can fetch conversations and messages from Supabase</done>
</task>

</tasks>

<verification>
1. Persistence module exists: ls supabase/functions/chat/persistence.ts
2. Pipeline uses persistence: grep "persistence" supabase/functions/chat/pipeline.ts
3. Done event has conversation_id: grep "conversation_id" supabase/functions/chat/streamHandler.ts
4. ChatDoneEvent has conversationId: grep "conversationId" lib/features/chat/domain/chat_event.dart
5. ChatStreamState has conversationId: grep "conversationId" lib/features/chat/domain/chat_stream_state.dart
6. Conversation repository is read-only: grep -v "insert\|update" lib/features/chat/data/chat_conversation_repository.dart (should show no insert/update)
7. Message repository is read-only: grep -v "insert\|update" lib/features/chat/data/chat_message_repository.dart
8. Codegen passes: `fvm dart run build_runner build --delete-conflicting-outputs`
9. No analyzer errors: `fvm flutter analyze`
</verification>

<success_criteria>
- Edge function creates conversations and saves messages (backend owns persistence)
- Done event includes conversation_id and follow_up_suggestions
- Flutter parses conversation_id from done event
- ChatStreamState has conversationId and followUpSuggestions fields
- Flutter repositories are READ-ONLY (no insert/update methods)
- Zero analyzer errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-conversation-discovery/04-03-SUMMARY.md`
</output>
