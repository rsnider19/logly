---
phase: 04-conversation-discovery
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - lib/features/chat/domain/chat_event.dart
  - lib/features/chat/data/sse_event_parser.dart
  - lib/features/chat/domain/chat_stream_state.dart
  - lib/features/chat/data/chat_conversation_repository.dart
  - lib/features/chat/data/chat_message_repository.dart
  - lib/features/chat/application/chat_persistence_service.dart
  - lib/app/database/drift_database.dart
autonomous: true

must_haves:
  truths:
    - "Flutter parses follow_up SSE events into ChatFollowUpEvent"
    - "ChatStreamState holds follow-up suggestions"
    - "Conversations can be saved to and loaded from Supabase"
    - "Messages can be saved to and loaded from Supabase"
    - "Conversations and messages cache to local Drift database"
  artifacts:
    - path: "lib/features/chat/domain/chat_event.dart"
      provides: "ChatFollowUpEvent type"
      contains: "ChatFollowUpEvent"
    - path: "lib/features/chat/domain/chat_stream_state.dart"
      provides: "followUpSuggestions field"
      contains: "followUpSuggestions"
    - path: "lib/features/chat/data/chat_conversation_repository.dart"
      provides: "Supabase CRUD for conversations"
      contains: "ChatConversationRepository"
    - path: "lib/features/chat/data/chat_message_repository.dart"
      provides: "Supabase CRUD for messages"
      contains: "ChatMessageRepository"
    - path: "lib/features/chat/application/chat_persistence_service.dart"
      provides: "Orchestrates save/load with Drift caching"
      contains: "ChatPersistenceService"
  key_links:
    - from: "lib/features/chat/data/sse_event_parser.dart"
      to: "domain/chat_event.dart"
      via: "ChatEvent.fromJson"
      pattern: "ChatEvent\\.fromJson"
    - from: "lib/features/chat/application/chat_persistence_service.dart"
      to: "data/chat_conversation_repository.dart"
      via: "repository injection"
      pattern: "_conversationRepository"
    - from: "lib/features/chat/application/chat_persistence_service.dart"
      to: "drift_database.dart"
      via: "local cache operations"
      pattern: "_db\\."
---

<objective>
Build the persistence layer: parse follow-up events in Flutter, create Supabase repositories for conversations and messages, and build a persistence service that orchestrates server sync with local Drift caching.

Purpose: Enable chat history to be saved server-side and cached locally for offline viewing and fast loads (CONV-02).
Output: ChatFollowUpEvent parsing, Supabase repositories, persistence service with Drift caching.
</objective>

<execution_context>
@/Users/robsnider/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robsnider/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-conversation-discovery/04-RESEARCH.md
@.planning/phases/04-conversation-discovery/04-01-SUMMARY.md
@.planning/phases/04-conversation-discovery/04-02-SUMMARY.md

# Existing code to extend
@lib/features/chat/domain/chat_event.dart
@lib/features/chat/domain/chat_stream_state.dart
@lib/features/chat/data/sse_event_parser.dart
@lib/app/database/drift_database.dart

# Domain models from Plan 01
@lib/features/chat/domain/chat_conversation.dart
@lib/features/chat/domain/chat_message.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ChatFollowUpEvent and update ChatStreamState</name>
  <files>
lib/features/chat/domain/chat_event.dart
lib/features/chat/domain/chat_stream_state.dart
lib/features/chat/data/sse_event_parser.dart
  </files>
  <action>
**Update lib/features/chat/domain/chat_event.dart:**

Add the follow_up event type to the ChatEvent sealed class. Add after the done factory:

```dart
/// Follow-up question suggestions.
@FreezedUnionValue('follow_up')
const factory ChatEvent.followUp({
  required List<String> suggestions,
}) = ChatFollowUpEvent;
```

The Freezed union with `unionKey: 'type'` will automatically deserialize `{"type": "follow_up", "suggestions": [...]}`.

**Update lib/features/chat/domain/chat_stream_state.dart:**

Add followUpSuggestions field to ChatStreamState:

```dart
/// Follow-up question suggestions (populated after AI response completes).
@Default([]) List<String> followUpSuggestions,
```

Add it after the `conversionId` field and before `errorMessage`.

**Verify sse_event_parser.dart:**

The existing SSE parser uses `ChatEvent.fromJson(jsonDecode(data))` which will automatically handle the new event type via Freezed's union deserialization. No changes needed to sse_event_parser.dart itself - just verify it uses ChatEvent.fromJson.

**Run build_runner** to regenerate Freezed classes:
```bash
fvm dart run build_runner build --delete-conflicting-outputs
```
  </action>
  <verify>Run `fvm dart run build_runner build --delete-conflicting-outputs` - should generate ChatFollowUpEvent in chat_event.freezed.dart with suggestions getter</verify>
  <done>ChatFollowUpEvent parses from SSE, ChatStreamState has followUpSuggestions field</done>
</task>

<task type="auto">
  <name>Task 2: Create Supabase repositories for conversations and messages</name>
  <files>
lib/features/chat/data/chat_conversation_repository.dart
lib/features/chat/data/chat_message_repository.dart
  </files>
  <action>
**Create lib/features/chat/data/chat_conversation_repository.dart:**

```dart
import 'package:logly/features/chat/domain/chat_conversation.dart';
import 'package:logly/services/supabase_service.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'chat_conversation_repository.g.dart';

/// Repository for chat conversation CRUD operations in Supabase.
///
/// All queries are automatically scoped to the authenticated user via RLS.
class ChatConversationRepository {
  ChatConversationRepository(this._supabase);

  final SupabaseService _supabase;

  /// Creates a new conversation and returns it.
  Future<ChatConversation> create({
    required String conversationId,
    required String userId,
    String? title,
  }) async {
    final now = DateTime.now().toUtc();
    final data = {
      'conversation_id': conversationId,
      'user_id': userId,
      'title': title,
      'created_at': now.toIso8601String(),
      'updated_at': now.toIso8601String(),
    };

    final response = await _supabase.client
        .from('chat_conversations')
        .insert(data)
        .select()
        .single();

    return ChatConversation.fromJson(response);
  }

  /// Updates conversation with latest follow-up IDs.
  Future<void> updateFollowUpIds({
    required String conversationId,
    String? lastResponseId,
    String? lastConversionId,
  }) async {
    await _supabase.client
        .from('chat_conversations')
        .update({
          'last_response_id': lastResponseId,
          'last_conversion_id': lastConversionId,
          'updated_at': DateTime.now().toUtc().toIso8601String(),
        })
        .eq('conversation_id', conversationId);
  }

  /// Gets the most recent conversation for the current user.
  Future<ChatConversation?> getMostRecent() async {
    final response = await _supabase.client
        .from('chat_conversations')
        .select()
        .order('updated_at', ascending: false)
        .limit(1)
        .maybeSingle();

    if (response == null) return null;
    return ChatConversation.fromJson(response);
  }

  /// Gets a conversation by ID.
  Future<ChatConversation?> getById(String conversationId) async {
    final response = await _supabase.client
        .from('chat_conversations')
        .select()
        .eq('conversation_id', conversationId)
        .maybeSingle();

    if (response == null) return null;
    return ChatConversation.fromJson(response);
  }
}

@Riverpod(keepAlive: true)
ChatConversationRepository chatConversationRepository(
  ChatConversationRepositoryRef ref,
) {
  return ChatConversationRepository(ref.watch(supabaseServiceProvider));
}
```

**Create lib/features/chat/data/chat_message_repository.dart:**

```dart
import 'package:logly/features/chat/domain/chat_message.dart';
import 'package:logly/services/supabase_service.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'chat_message_repository.g.dart';

/// Repository for chat message CRUD operations in Supabase.
///
/// Messages are scoped via conversation ownership (RLS subquery).
class ChatMessageRepository {
  ChatMessageRepository(this._supabase);

  final SupabaseService _supabase;

  /// Inserts a new message.
  Future<ChatMessage> insert(ChatMessage message) async {
    final data = {
      'message_id': message.messageId,
      'conversation_id': message.conversationId,
      'role': message.role.name,
      'content': message.content,
      'metadata': message.metadata,
      'created_at': message.createdAt.toUtc().toIso8601String(),
    };

    final response = await _supabase.client
        .from('chat_messages')
        .insert(data)
        .select()
        .single();

    return _parseMessage(response);
  }

  /// Gets messages for a conversation, ordered by creation time.
  ///
  /// [limit] defaults to 50 messages (most recent first for pagination).
  Future<List<ChatMessage>> getByConversation(
    String conversationId, {
    int limit = 50,
    int offset = 0,
  }) async {
    final response = await _supabase.client
        .from('chat_messages')
        .select()
        .eq('conversation_id', conversationId)
        .order('created_at', ascending: true)
        .range(offset, offset + limit - 1);

    return (response as List<dynamic>).map(_parseMessage).toList();
  }

  ChatMessage _parseMessage(Map<String, dynamic> json) {
    return ChatMessage(
      messageId: json['message_id'] as String,
      conversationId: json['conversation_id'] as String,
      role: ChatMessageRole.values.byName(json['role'] as String),
      content: json['content'] as String,
      metadata: json['metadata'] as Map<String, dynamic>?,
      createdAt: DateTime.parse(json['created_at'] as String),
    );
  }
}

@Riverpod(keepAlive: true)
ChatMessageRepository chatMessageRepository(
  ChatMessageRepositoryRef ref,
) {
  return ChatMessageRepository(ref.watch(supabaseServiceProvider));
}
```

Run build_runner after creating these files.
  </action>
  <verify>Run `fvm dart run build_runner build --delete-conflicting-outputs` - should generate .g.dart provider files</verify>
  <done>ChatConversationRepository and ChatMessageRepository can CRUD to Supabase</done>
</task>

<task type="auto">
  <name>Task 3: Create persistence service with Drift caching</name>
  <files>
lib/features/chat/application/chat_persistence_service.dart
lib/app/database/drift_database.dart
  </files>
  <action>
**First, add Drift operations to lib/app/database/drift_database.dart:**

Add these methods to the AppDatabase class (after the existing CachedData operations):

```dart
// MARK: - ChatConversations operations

/// Upserts a chat conversation to local cache.
Future<void> upsertConversation({
  required String conversationId,
  required String userId,
  String? title,
  String? lastResponseId,
  String? lastConversionId,
  required DateTime createdAt,
  required DateTime updatedAt,
  String syncStatus = 'synced',
}) async {
  await into(chatConversations).insertOnConflictUpdate(
    ChatConversationsCompanion.insert(
      conversationId: conversationId,
      userId: userId,
      title: Value(title),
      lastResponseId: Value(lastResponseId),
      lastConversionId: Value(lastConversionId),
      createdAt: createdAt,
      updatedAt: updatedAt,
      syncStatus: Value(syncStatus),
    ),
  );
}

/// Gets the most recent conversation from local cache.
Future<ChatConversationsData?> getLatestConversation(String userId) async {
  return (select(chatConversations)
        ..where((t) => t.userId.equals(userId))
        ..orderBy([(t) => OrderingTerm.desc(t.updatedAt)])
        ..limit(1))
      .getSingleOrNull();
}

/// Gets a conversation by ID from local cache.
Future<ChatConversationsData?> getConversationById(String conversationId) async {
  return (select(chatConversations)
        ..where((t) => t.conversationId.equals(conversationId)))
      .getSingleOrNull();
}

// MARK: - ChatMessages operations

/// Upserts a chat message to local cache.
Future<void> upsertMessage({
  required String messageId,
  required String conversationId,
  required String role,
  required String content,
  String? metadata,
  required DateTime createdAt,
  String syncStatus = 'synced',
}) async {
  await into(chatMessages).insertOnConflictUpdate(
    ChatMessagesCompanion.insert(
      messageId: messageId,
      conversationId: conversationId,
      role: role,
      content: content,
      metadata: Value(metadata),
      createdAt: createdAt,
      syncStatus: Value(syncStatus),
    ),
  );
}

/// Gets messages for a conversation from local cache.
Future<List<ChatMessagesData>> getMessagesByConversation(
  String conversationId, {
  int limit = 50,
}) async {
  return (select(chatMessages)
        ..where((t) => t.conversationId.equals(conversationId))
        ..orderBy([(t) => OrderingTerm.asc(t.createdAt)])
        ..limit(limit))
      .get();
}
```

**Create lib/features/chat/application/chat_persistence_service.dart:**

```dart
import 'dart:convert';

import 'package:logly/app/database/drift_database.dart';
import 'package:logly/features/chat/data/chat_conversation_repository.dart';
import 'package:logly/features/chat/data/chat_message_repository.dart';
import 'package:logly/features/chat/domain/chat_conversation.dart';
import 'package:logly/features/chat/domain/chat_message.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:uuid/uuid.dart';

part 'chat_persistence_service.g.dart';

/// Service for persisting chat conversations and messages.
///
/// Uses cache-first pattern: saves to local Drift immediately,
/// then syncs to Supabase in background.
class ChatPersistenceService {
  ChatPersistenceService(
    this._db,
    this._conversationRepository,
    this._messageRepository,
  );

  final AppDatabase _db;
  final ChatConversationRepository _conversationRepository;
  final ChatMessageRepository _messageRepository;

  static const _uuid = Uuid();

  /// Creates a new conversation.
  ///
  /// Saves to local Drift first, then syncs to Supabase.
  /// Returns the conversation ID for immediate use.
  Future<String> createConversation({
    required String userId,
    String? title,
  }) async {
    final conversationId = _uuid.v4();
    final now = DateTime.now().toUtc();

    // Save to local cache first (optimistic)
    await _db.upsertConversation(
      conversationId: conversationId,
      userId: userId,
      title: title,
      createdAt: now,
      updatedAt: now,
      syncStatus: 'pending_upload',
    );

    // Sync to Supabase
    try {
      await _conversationRepository.create(
        conversationId: conversationId,
        userId: userId,
        title: title,
      );
      // Mark as synced
      await _db.upsertConversation(
        conversationId: conversationId,
        userId: userId,
        title: title,
        createdAt: now,
        updatedAt: now,
        syncStatus: 'synced',
      );
    } catch (e) {
      // Keep local, will retry sync later
    }

    return conversationId;
  }

  /// Saves a user message and AI response pair after response completes.
  Future<void> saveCompletedResponse({
    required String conversationId,
    required String userMessage,
    required String aiResponse,
    required String? responseId,
    required String? conversionId,
    List<String>? followUpSuggestions,
    Map<String, dynamic>? stepMetadata,
  }) async {
    final now = DateTime.now().toUtc();
    final userMsgId = _uuid.v4();
    final aiMsgId = _uuid.v4();

    // Build AI message metadata
    final aiMetadata = <String, dynamic>{
      if (followUpSuggestions != null && followUpSuggestions.isNotEmpty)
        'followUpSuggestions': followUpSuggestions,
      if (stepMetadata != null) ...stepMetadata,
    };

    // Save user message to local cache
    await _db.upsertMessage(
      messageId: userMsgId,
      conversationId: conversationId,
      role: 'user',
      content: userMessage,
      createdAt: now.subtract(const Duration(milliseconds: 100)), // Slightly before AI
    );

    // Save AI message to local cache
    await _db.upsertMessage(
      messageId: aiMsgId,
      conversationId: conversationId,
      role: 'assistant',
      content: aiResponse,
      metadata: aiMetadata.isNotEmpty ? jsonEncode(aiMetadata) : null,
      createdAt: now,
    );

    // Update conversation with follow-up IDs
    final existingConv = await _db.getConversationById(conversationId);
    if (existingConv != null) {
      await _db.upsertConversation(
        conversationId: conversationId,
        userId: existingConv.userId,
        title: existingConv.title,
        lastResponseId: responseId,
        lastConversionId: conversionId,
        createdAt: existingConv.createdAt,
        updatedAt: now,
      );
    }

    // Sync to Supabase (fire and forget - don't block on network)
    _syncMessagesToSupabase(
      conversationId: conversationId,
      userMsgId: userMsgId,
      userMessage: userMessage,
      aiMsgId: aiMsgId,
      aiResponse: aiResponse,
      aiMetadata: aiMetadata,
      responseId: responseId,
      conversionId: conversionId,
      now: now,
    );
  }

  Future<void> _syncMessagesToSupabase({
    required String conversationId,
    required String userMsgId,
    required String userMessage,
    required String aiMsgId,
    required String aiResponse,
    required Map<String, dynamic> aiMetadata,
    required String? responseId,
    required String? conversionId,
    required DateTime now,
  }) async {
    try {
      // Save user message
      await _messageRepository.insert(
        ChatMessage(
          messageId: userMsgId,
          conversationId: conversationId,
          role: ChatMessageRole.user,
          content: userMessage,
          createdAt: now.subtract(const Duration(milliseconds: 100)),
        ),
      );

      // Save AI message
      await _messageRepository.insert(
        ChatMessage(
          messageId: aiMsgId,
          conversationId: conversationId,
          role: ChatMessageRole.assistant,
          content: aiResponse,
          metadata: aiMetadata.isNotEmpty ? aiMetadata : null,
          createdAt: now,
        ),
      );

      // Update conversation follow-up IDs
      await _conversationRepository.updateFollowUpIds(
        conversationId: conversationId,
        lastResponseId: responseId,
        lastConversionId: conversionId,
      );
    } catch (e) {
      // Network error - messages stay in local cache
      // Could implement retry queue in future
    }
  }

  /// Loads the most recent conversation for the user.
  ///
  /// Returns from local cache first (fast), then refreshes from Supabase.
  Future<ChatConversation?> getMostRecentConversation(String userId) async {
    // Try local cache first
    final localConv = await _db.getLatestConversation(userId);
    if (localConv != null) {
      return ChatConversation(
        conversationId: localConv.conversationId,
        userId: localConv.userId,
        title: localConv.title,
        lastResponseId: localConv.lastResponseId,
        lastConversionId: localConv.lastConversionId,
        createdAt: localConv.createdAt,
        updatedAt: localConv.updatedAt,
      );
    }

    // No local cache, try Supabase
    final remoteConv = await _conversationRepository.getMostRecent();
    if (remoteConv != null) {
      // Cache locally
      await _db.upsertConversation(
        conversationId: remoteConv.conversationId,
        userId: remoteConv.userId,
        title: remoteConv.title,
        lastResponseId: remoteConv.lastResponseId,
        lastConversionId: remoteConv.lastConversionId,
        createdAt: remoteConv.createdAt,
        updatedAt: remoteConv.updatedAt,
      );
    }
    return remoteConv;
  }

  /// Loads messages for a conversation.
  ///
  /// Returns from local cache, falls back to Supabase.
  Future<List<ChatMessage>> getMessages(String conversationId, {int limit = 50}) async {
    // Try local cache first
    final localMessages = await _db.getMessagesByConversation(conversationId, limit: limit);
    if (localMessages.isNotEmpty) {
      return localMessages.map((m) => ChatMessage(
        messageId: m.messageId,
        conversationId: m.conversationId,
        role: ChatMessageRole.values.byName(m.role),
        content: m.content,
        metadata: m.metadata != null ? jsonDecode(m.metadata!) as Map<String, dynamic> : null,
        createdAt: m.createdAt,
      )).toList();
    }

    // No local cache, try Supabase
    final remoteMessages = await _messageRepository.getByConversation(conversationId, limit: limit);
    // Cache locally
    for (final msg in remoteMessages) {
      await _db.upsertMessage(
        messageId: msg.messageId,
        conversationId: msg.conversationId,
        role: msg.role.name,
        content: msg.content,
        metadata: msg.metadata != null ? jsonEncode(msg.metadata) : null,
        createdAt: msg.createdAt,
      );
    }
    return remoteMessages;
  }
}

@Riverpod(keepAlive: true)
ChatPersistenceService chatPersistenceService(ChatPersistenceServiceRef ref) {
  return ChatPersistenceService(
    ref.watch(appDatabaseProvider),
    ref.watch(chatConversationRepositoryProvider),
    ref.watch(chatMessageRepositoryProvider),
  );
}
```

Run build_runner after completing these changes.
  </action>
  <verify>Run `fvm dart run build_runner build --delete-conflicting-outputs` and `fvm flutter analyze` - should pass with no errors</verify>
  <done>ChatPersistenceService saves to Drift first then syncs to Supabase, loads from cache with server fallback</done>
</task>

</tasks>

<verification>
1. ChatFollowUpEvent exists: grep "ChatFollowUpEvent" lib/features/chat/domain/chat_event.freezed.dart
2. followUpSuggestions in state: grep "followUpSuggestions" lib/features/chat/domain/chat_stream_state.dart
3. Conversation repository exists: ls lib/features/chat/data/chat_conversation_repository.dart
4. Message repository exists: ls lib/features/chat/data/chat_message_repository.dart
5. Persistence service exists: ls lib/features/chat/application/chat_persistence_service.dart
6. Drift operations added: grep "upsertConversation" lib/app/database/drift_database.dart
7. Codegen passes: `fvm dart run build_runner build --delete-conflicting-outputs` exits 0
8. No analyzer errors: `fvm flutter analyze`
</verification>

<success_criteria>
- ChatEvent.followUp variant parses from SSE JSON
- ChatStreamState has followUpSuggestions list field
- ChatConversationRepository can create, update IDs, get most recent
- ChatMessageRepository can insert and get by conversation
- ChatPersistenceService orchestrates local cache + server sync
- Drift database has chat conversation and message operations
- Zero analyzer errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-conversation-discovery/04-03-SUMMARY.md`
</output>
