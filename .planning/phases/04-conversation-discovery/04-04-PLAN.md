---
phase: 04-conversation-discovery
plan: 04
type: execute
wave: 3
depends_on: ["04-03"]
files_modified:
  - lib/features/chat/application/chat_service.dart
  - lib/features/chat/presentation/providers/chat_stream_provider.dart
  - lib/features/chat/presentation/providers/chat_ui_provider.dart
  - lib/features/chat/presentation/widgets/follow_up_chips.dart
  - lib/features/chat/presentation/screens/chat_screen.dart
autonomous: false

must_haves:
  truths:
    - "Follow-up questions appear as tappable chips after AI response"
    - "Tapping a follow-up chip sends that question immediately"
    - "Conversation persists to Supabase after each AI response"
    - "Reopening the app shows previous conversation with messages"
    - "Multi-turn context is maintained via responseId/conversionId"
  artifacts:
    - path: "lib/features/chat/presentation/widgets/follow_up_chips.dart"
      provides: "Tappable follow-up suggestion chips"
      contains: "FollowUpChips"
    - path: "lib/features/chat/presentation/providers/chat_stream_provider.dart"
      provides: "Persistence trigger on completion"
      contains: "chatPersistenceServiceProvider"
    - path: "lib/features/chat/presentation/screens/chat_screen.dart"
      provides: "Follow-up chips integrated, conversation loading on init"
      contains: "FollowUpChips"
  key_links:
    - from: "lib/features/chat/presentation/providers/chat_stream_provider.dart"
      to: "application/chat_persistence_service.dart"
      via: "saveCompletedResponse call"
      pattern: "saveCompletedResponse"
    - from: "lib/features/chat/presentation/screens/chat_screen.dart"
      to: "widgets/follow_up_chips.dart"
      via: "widget import and usage"
      pattern: "FollowUpChips"
    - from: "lib/features/chat/application/chat_service.dart"
      to: "domain/chat_event.dart"
      via: "ChatFollowUpEvent handling"
      pattern: "ChatFollowUpEvent"
---

<objective>
Complete the UI integration: wire persistence to the chat flow, create follow-up chips widget, and load conversation history on screen open.

Purpose: Enable the complete user experience for Phase 4 - multi-turn conversations that persist, follow-up suggestions after responses, and conversation restoration on app reopen.
Output: Working end-to-end flow with persistence, follow-up chips, and conversation loading.
</objective>

<execution_context>
@/Users/robsnider/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robsnider/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-conversation-discovery/04-RESEARCH.md
@.planning/phases/04-conversation-discovery/04-01-SUMMARY.md
@.planning/phases/04-conversation-discovery/04-02-SUMMARY.md
@.planning/phases/04-conversation-discovery/04-03-SUMMARY.md

# Files to modify
@lib/features/chat/application/chat_service.dart
@lib/features/chat/presentation/providers/chat_stream_provider.dart
@lib/features/chat/presentation/providers/chat_ui_provider.dart
@lib/features/chat/presentation/screens/chat_screen.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Handle follow-up events in ChatService and update state</name>
  <files>
lib/features/chat/application/chat_service.dart
lib/features/chat/presentation/providers/chat_stream_provider.dart
  </files>
  <action>
**Update lib/features/chat/application/chat_service.dart:**

Add handling for ChatFollowUpEvent in the event processing switch statement. Find the existing switch on ChatEvent and add a case for followUp:

```dart
ChatFollowUpEvent(:final suggestions) => {
  // Store suggestions in state for UI display
  // These are emitted after response completes but before done
  currentState = currentState.copyWith(
    followUpSuggestions: suggestions,
  ),
  onStateUpdate(currentState),
},
```

Add this case in the existing switch statement that handles step, textDelta, responseId, conversionId, error, and done events.

**Update lib/features/chat/presentation/providers/chat_stream_provider.dart:**

1. Import the persistence service:
```dart
import 'package:logly/features/chat/application/chat_persistence_service.dart';
```

2. Add fields to track current conversation and user query:
```dart
/// Current conversation ID (set on first message, persists across requests).
String? _currentConversationId;

/// The user's query for the current request (for persistence).
String? _currentQuery;
```

3. Inject persistence service in build():
```dart
late ChatPersistenceService _persistence;

@override
ChatStreamState build() {
  _service = ref.watch(chatServiceProvider);
  _persistence = ref.watch(chatPersistenceServiceProvider);
  ref.onDispose(() {
    _service.cancel();
  });
  return const ChatStreamState();
}
```

4. In sendQuestion, before the service call, store the query and ensure conversation exists:
```dart
Future<void> sendQuestion(String query) async {
  // ... existing guard check ...

  // Store query for persistence
  _currentQuery = query;

  // Ensure we have a conversation ID
  if (_currentConversationId == null) {
    // Get user ID from auth
    final user = ref.read(currentUserProvider);
    if (user != null) {
      _currentConversationId = await _persistence.createConversation(
        userId: user.id,
        title: query.length > 50 ? '${query.substring(0, 47)}...' : query,
      );
    }
  }

  // Reset display state for new request
  state = const ChatStreamState(status: ChatConnectionStatus.connecting);

  // ... rest of existing code ...
}
```

5. After the service call completes successfully (after capturing IDs), save to persistence:
```dart
// After: _lastResponseId = state.responseId; _lastConversionId = state.conversionId;

// Save completed response to persistence
if (_currentConversationId != null && _currentQuery != null && state.fullText.isNotEmpty) {
  unawaited(_persistence.saveCompletedResponse(
    conversationId: _currentConversationId!,
    userMessage: _currentQuery!,
    aiResponse: state.fullText,
    responseId: state.responseId,
    conversionId: state.conversionId,
    followUpSuggestions: state.followUpSuggestions.isNotEmpty ? state.followUpSuggestions : null,
    stepMetadata: state.completedSteps.isNotEmpty
        ? {'steps': state.completedSteps.map((s) => s.name).toList()}
        : null,
  ));
}
```

6. Add import for `unawaited` from `dart:async` and `currentUserProvider`:
```dart
import 'dart:async';
import 'package:logly/features/auth/presentation/providers/auth_state_provider.dart';
```

7. Update resetConversation to also clear the conversation ID:
```dart
void resetConversation() {
  _lastResponseId = null;
  _lastConversionId = null;
  _currentConversationId = null;
  _currentQuery = null;
  state = const ChatStreamState();
}
```

8. Add method to load existing conversation:
```dart
/// Loads an existing conversation's context (IDs for follow-up chaining).
///
/// Called when restoring a conversation from persistence.
void setConversationContext({
  required String conversationId,
  String? responseId,
  String? conversionId,
}) {
  _currentConversationId = conversationId;
  _lastResponseId = responseId;
  _lastConversionId = conversionId;
}
```
  </action>
  <verify>Run `fvm dart run build_runner build --delete-conflicting-outputs` and `fvm flutter analyze` - should pass</verify>
  <done>ChatService handles follow-up events, ChatStreamStateNotifier triggers persistence on completion</done>
</task>

<task type="auto">
  <name>Task 2: Create follow-up chips widget and integrate into chat screen</name>
  <files>
lib/features/chat/presentation/widgets/follow_up_chips.dart
lib/features/chat/presentation/screens/chat_screen.dart
lib/features/chat/presentation/providers/chat_ui_provider.dart
  </files>
  <action>
**Create lib/features/chat/presentation/widgets/follow_up_chips.dart:**

```dart
import 'package:flutter/material.dart';
import 'package:lucide_icons_flutter/lucide_icons.dart';

/// Tappable follow-up question suggestions shown after an AI response.
///
/// Displays 2-3 suggestions as horizontal chips that send the question
/// immediately when tapped.
class FollowUpChips extends StatelessWidget {
  const FollowUpChips({
    required this.suggestions,
    required this.onTap,
    super.key,
  });

  /// List of follow-up question suggestions (max 3).
  final List<String> suggestions;

  /// Called with the suggestion text when the user taps a chip.
  final void Function(String question) onTap;

  @override
  Widget build(BuildContext context) {
    if (suggestions.isEmpty) return const SizedBox.shrink();

    final theme = Theme.of(context);

    return Padding(
      padding: const EdgeInsets.only(left: 16, right: 16, top: 8, bottom: 16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            'Continue the conversation:',
            style: theme.textTheme.labelSmall?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: suggestions.take(3).map((suggestion) {
              return ActionChip(
                label: Text(
                  suggestion,
                  style: theme.textTheme.bodySmall,
                ),
                onPressed: () => onTap(suggestion),
                avatar: Icon(
                  LucideIcons.cornerDownRight,
                  size: 14,
                  color: theme.colorScheme.primary,
                ),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20),
                ),
                backgroundColor: theme.colorScheme.surfaceContainerHighest,
                side: BorderSide.none,
              );
            }).toList(),
          ),
        ],
      ),
    );
  }
}
```

**Update lib/features/chat/presentation/providers/chat_ui_provider.dart:**

Add follow-up suggestions to the AI message metadata so they display after the message. Find where the AI TextMessage is created (after stream completion) and include follow-up suggestions in metadata:

```dart
// When creating the completed AI message, include follow-up suggestions in metadata
// Find the line where TextMessage is created for the AI response
// Add to the metadata map:
if (streamState.followUpSuggestions.isNotEmpty) {
  metadata['followUpSuggestions'] = streamState.followUpSuggestions;
}
```

Also expose the follow-up suggestions for the screen to access via a getter or by watching chatStreamStateProvider.

**Update lib/features/chat/presentation/screens/chat_screen.dart:**

1. Import the follow-up chips widget:
```dart
import 'package:logly/features/chat/presentation/widgets/follow_up_chips.dart';
```

2. In `_buildTextMessage` for AI messages (not streaming), add follow-up chips after the GptMarkdown:
```dart
// After the GptMarkdown in the AI message Column, add:
if (message.metadata?['followUpSuggestions'] != null)
  FollowUpChips(
    suggestions: (message.metadata!['followUpSuggestions'] as List<dynamic>).cast<String>(),
    onTap: _handleSendMessage,
  ),
```

So the full AI message builder becomes:
```dart
return Column(
  crossAxisAlignment: CrossAxisAlignment.start,
  children: [
    _buildStepProgress(message.metadata, theme),
    Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: GptMarkdown(message.text, style: theme.textTheme.bodyLarge),
    ),
    if (message.metadata?['followUpSuggestions'] != null)
      FollowUpChips(
        suggestions: (message.metadata!['followUpSuggestions'] as List<dynamic>).cast<String>(),
        onTap: _handleSendMessage,
      ),
  ],
);
```

3. Also show follow-up chips during streaming completion. In `_buildTextStreamMessage`, add follow-up chips when status is completing or completed:
```dart
// After FlyerChatTextStreamMessage, conditionally show follow-up chips
if ((streamState.status == ChatConnectionStatus.completed ||
     streamState.status == ChatConnectionStatus.completing) &&
    streamState.followUpSuggestions.isNotEmpty)
  FollowUpChips(
    suggestions: streamState.followUpSuggestions,
    onTap: _handleSendMessage,
  ),
```
  </action>
  <verify>Run `fvm flutter analyze` - should pass with no errors</verify>
  <done>FollowUpChips widget created, integrated into chat screen for both static and streaming messages</done>
</task>

<task type="auto">
  <name>Task 3: Load conversation history on screen open</name>
  <files>lib/features/chat/presentation/screens/chat_screen.dart</files>
  <action>
**Update lib/features/chat/presentation/screens/chat_screen.dart:**

1. Import the persistence service and auth providers:
```dart
import 'package:logly/features/chat/application/chat_persistence_service.dart';
import 'package:flutter_chat_core/flutter_chat_core.dart';
```

2. Add a flag to track if initial load has been attempted:
```dart
bool _initialLoadComplete = false;
```

3. Override initState to trigger conversation loading:
```dart
@override
void initState() {
  super.initState();
  // Load conversation after first frame
  WidgetsBinding.instance.addPostFrameCallback((_) {
    _loadExistingConversation();
  });
}
```

4. Add the load method:
```dart
Future<void> _loadExistingConversation() async {
  if (_initialLoadComplete) return;
  _initialLoadComplete = true;

  final user = ref.read(currentUserProvider);
  if (user == null) return;

  final persistence = ref.read(chatPersistenceServiceProvider);
  final conversation = await persistence.getMostRecentConversation(user.id);

  if (conversation == null || !mounted) return;

  // Load messages
  final messages = await persistence.getMessages(conversation.conversationId);
  if (messages.isEmpty || !mounted) return;

  // Set conversation context for follow-up chaining
  ref.read(chatStreamStateProvider.notifier).setConversationContext(
    conversationId: conversation.conversationId,
    responseId: conversation.lastResponseId,
    conversionId: conversation.lastConversionId,
  );

  // Convert domain messages to UI messages and add to controller
  final controller = ref.read(chatUiStateProvider);
  for (final msg in messages) {
    final uiMessage = _domainToUiMessage(msg, user.id);
    await controller.insertMessage(uiMessage);
  }
}

Message _domainToUiMessage(ChatMessage msg, String currentUserId) {
  final authorId = msg.role == ChatMessageRole.user ? currentUserId : 'ai';

  if (msg.role == ChatMessageRole.system) {
    return SystemMessage(
      id: msg.messageId,
      text: msg.content,
      createdAt: msg.createdAt,
    );
  }

  return TextMessage(
    id: msg.messageId,
    authorId: authorId,
    text: msg.content,
    createdAt: msg.createdAt,
    metadata: msg.metadata,
  );
}
```

5. Import ChatMessage and ChatMessageRole from domain:
```dart
import 'package:logly/features/chat/domain/chat_message.dart';
```

6. Ensure the Message, TextMessage, SystemMessage types are available from flutter_chat_core (they should already be imported).
  </action>
  <verify>Run the app, close it, reopen it, navigate to chat - should show previous conversation messages</verify>
  <done>Chat screen loads existing conversation on open, with messages and follow-up context restored</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Phase 4 functionality: multi-turn conversations with persistence, follow-up suggestion chips, dynamic starter questions, and conversation restoration</what-built>
  <how-to-verify>
1. Fresh start test:
   - Force-quit the app and clear app data (or delete the app)
   - Open the app and navigate to the chat screen
   - Verify: Empty state shows dynamic prompts (not hardcoded text)
   - Tap a starter question - should send immediately

2. Conversation flow test:
   - Send a question like "What did I log this week?"
   - Wait for the AI response to complete
   - Verify: 2-3 follow-up suggestion chips appear below the AI response
   - Verify: Tapping a follow-up chip sends that question
   - Verify: The AI's follow-up answer shows context from the first question

3. Persistence test:
   - After completing a conversation with at least 2 exchanges
   - Force-quit the app (not just background)
   - Reopen the app and navigate to chat
   - Verify: Previous messages appear (both user and AI messages)
   - Verify: Follow-up chips appear on the last AI message
   - Verify: Sending a new question continues the conversation context

4. Multi-turn context test:
   - Ask "How many times did I exercise this week?"
   - After response, ask "What about last week?"
   - Verify: AI response compares to the previous week (shows it understood "last week" refers to exercise)

5. Error recovery test:
   - Enable airplane mode
   - Send a question
   - Verify: Error message appears
   - Verify: User's question text is restored to the input field
   - Disable airplane mode and retry
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. Follow-up event handling: grep "ChatFollowUpEvent" lib/features/chat/application/chat_service.dart
2. Persistence trigger: grep "saveCompletedResponse" lib/features/chat/presentation/providers/chat_stream_provider.dart
3. Follow-up chips widget: ls lib/features/chat/presentation/widgets/follow_up_chips.dart
4. Chips in screen: grep "FollowUpChips" lib/features/chat/presentation/screens/chat_screen.dart
5. Conversation loading: grep "_loadExistingConversation" lib/features/chat/presentation/screens/chat_screen.dart
6. Codegen passes: `fvm dart run build_runner build --delete-conflicting-outputs`
7. No analyzer errors: `fvm flutter analyze`
</verification>

<success_criteria>
- Follow-up events from SSE update state with suggestions
- Response completion triggers persistence save
- FollowUpChips widget displays after AI responses
- Tapping a chip sends the follow-up question
- Conversation loads on screen open with messages
- Multi-turn context works via preserved IDs
- Human verification confirms all flows work end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/04-conversation-discovery/04-04-SUMMARY.md`
</output>
