---
phase: 04-conversation-discovery
plan: 04
type: execute
wave: 3
depends_on: ["04-03"]
files_modified:
  - lib/features/chat/application/chat_service.dart
  - lib/features/chat/presentation/providers/chat_stream_provider.dart
  - lib/features/chat/presentation/providers/chat_ui_provider.dart
  - lib/features/chat/presentation/widgets/follow_up_chips.dart
  - lib/features/chat/presentation/screens/chat_screen.dart
  - lib/features/chat/presentation/screens/chat_history_screen.dart
  - lib/app/router/app_router.dart
autonomous: false

must_haves:
  truths:
    - "Empty state shown on chat screen open (not auto-load last conversation)"
    - "Follow-up questions appear as tappable chips after AI response"
    - "Tapping a follow-up chip sends that question immediately"
    - "History button in header opens conversation history list"
    - "Selecting a conversation from history loads its messages"
    - "New Chat button starts a fresh conversation"
    - "Multi-turn context is maintained via conversationId from backend"
  artifacts:
    - path: "lib/features/chat/presentation/widgets/follow_up_chips.dart"
      provides: "Tappable follow-up suggestion chips"
      contains: "FollowUpChips"
    - path: "lib/features/chat/presentation/screens/chat_history_screen.dart"
      provides: "Conversation history list"
      contains: "ChatHistoryScreen"
    - path: "lib/features/chat/presentation/screens/chat_screen.dart"
      provides: "History button, New Chat button, empty state"
      contains: "ChatHistoryRoute"
  key_links:
    - from: "lib/features/chat/presentation/screens/chat_screen.dart"
      to: "screens/chat_history_screen.dart"
      via: "navigation"
      pattern: "ChatHistoryRoute"
    - from: "lib/features/chat/presentation/screens/chat_screen.dart"
      to: "widgets/follow_up_chips.dart"
      via: "widget import and usage"
      pattern: "FollowUpChips"
    - from: "lib/features/chat/application/chat_service.dart"
      to: "domain/chat_event.dart"
      via: "ChatDoneEvent handling"
      pattern: "ChatDoneEvent"
---

<objective>
Complete the UI integration: handle done event with conversation_id and follow-ups, create follow-up chips, add history button and screen, add new chat button, show empty state on open (not auto-load).

Purpose: Enable the complete user experience for Phase 4 - empty state with starter questions, follow-up suggestions after responses, conversation history navigation, and new chat functionality. Per user decision, NO auto-load of last conversation on screen open.
Output: Working end-to-end flow with empty state, follow-up chips, history list, and new chat button.
</objective>

<execution_context>
@/Users/robsnider/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robsnider/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-conversation-discovery/04-CONTEXT.md
@.planning/phases/04-conversation-discovery/04-01-SUMMARY.md
@.planning/phases/04-conversation-discovery/04-02-SUMMARY.md
@.planning/phases/04-conversation-discovery/04-03-SUMMARY.md

# Files to modify
@lib/features/chat/application/chat_service.dart
@lib/features/chat/presentation/providers/chat_stream_provider.dart
@lib/features/chat/presentation/providers/chat_ui_provider.dart
@lib/features/chat/presentation/screens/chat_screen.dart
@lib/app/router/app_router.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Handle done event with conversationId and followUpSuggestions</name>
  <files>
lib/features/chat/application/chat_service.dart
lib/features/chat/presentation/providers/chat_stream_provider.dart
  </files>
  <action>
**Update lib/features/chat/application/chat_service.dart:**

Modify the done event handler to extract conversationId and followUpSuggestions:

```dart
ChatDoneEvent(:final conversationId, :final followUpSuggestions) => {
  currentState = currentState.copyWith(
    status: ChatConnectionStatus.completed,
    conversationId: conversationId,
    followUpSuggestions: followUpSuggestions,
  ),
  onStateUpdate(currentState),
},
```

**Update lib/features/chat/presentation/providers/chat_stream_provider.dart:**

1. Track current conversation ID for follow-up requests:
```dart
/// Current conversation ID (received from backend on first message).
String? _currentConversationId;
```

2. In the state update handler (where you process state changes from ChatService), capture the conversationId:
```dart
// When processing state update after done event:
if (state.conversationId != null) {
  _currentConversationId = state.conversationId;
}
```

3. In sendQuestion, pass the conversation ID to the edge function:
```dart
Future<void> sendQuestion(String query) async {
  // ... existing guard check ...

  // Reset display state for new request but keep conversation context
  state = state.copyWith(
    status: ChatConnectionStatus.connecting,
    followUpSuggestions: [], // Clear previous suggestions
  );

  // Pass existing conversation ID to continue the conversation
  await _service.sendQuestion(
    query,
    conversationId: _currentConversationId, // Pass to edge function
    // ... other params
  );
}
```

4. Update ChatService.sendQuestion (if needed) to accept and include conversationId in the request body to the edge function.

5. Add method to start a new conversation (clears conversation ID):
```dart
/// Resets conversation state to start fresh.
///
/// Called when user taps "New Chat" button.
void startNewConversation() {
  _currentConversationId = null;
  state = const ChatStreamState();
}
```

6. Add method to load a specific conversation:
```dart
/// Sets the conversation ID for continuing an existing conversation.
///
/// Called when loading from history.
void setConversationId(String conversationId) {
  _currentConversationId = conversationId;
}
```
  </action>
  <verify>Run `fvm dart run build_runner build --delete-conflicting-outputs` and `fvm flutter analyze` - should pass</verify>
  <done>ChatService handles done event with conversationId and followUpSuggestions, provider tracks conversation ID</done>
</task>

<task type="auto">
  <name>Task 2: Create follow-up chips widget</name>
  <files>
lib/features/chat/presentation/widgets/follow_up_chips.dart
  </files>
  <action>
**Create lib/features/chat/presentation/widgets/follow_up_chips.dart:**

```dart
import 'package:flutter/material.dart';
import 'package:lucide_icons_flutter/lucide_icons.dart';

/// Tappable follow-up question suggestions shown after an AI response.
///
/// Displays 2-3 suggestions as horizontal chips that send the question
/// immediately when tapped. Per user decision:
/// - Chips stay visible while user types
/// - Chips removed when user sends a message (their own or tapping a chip)
class FollowUpChips extends StatelessWidget {
  const FollowUpChips({
    required this.suggestions,
    required this.onTap,
    super.key,
  });

  /// List of follow-up question suggestions (max 3).
  final List<String> suggestions;

  /// Called with the suggestion text when the user taps a chip.
  final void Function(String question) onTap;

  @override
  Widget build(BuildContext context) {
    if (suggestions.isEmpty) return const SizedBox.shrink();

    final theme = Theme.of(context);

    return Padding(
      padding: const EdgeInsets.only(left: 16, right: 16, top: 8, bottom: 16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            'Continue the conversation:',
            style: theme.textTheme.labelSmall?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: suggestions.take(3).map((suggestion) {
              return ActionChip(
                label: Text(
                  suggestion,
                  style: theme.textTheme.bodySmall,
                ),
                onPressed: () => onTap(suggestion),
                avatar: Icon(
                  LucideIcons.cornerDownRight,
                  size: 14,
                  color: theme.colorScheme.primary,
                ),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20),
                ),
                backgroundColor: theme.colorScheme.surfaceContainerHighest,
                side: BorderSide.none,
              );
            }).toList(),
          ),
        ],
      ),
    );
  }
}
```
  </action>
  <verify>File exists at lib/features/chat/presentation/widgets/follow_up_chips.dart</verify>
  <done>FollowUpChips widget created with proper styling and tap handling</done>
</task>

<task type="auto">
  <name>Task 3: Create conversation history screen</name>
  <files>
lib/features/chat/presentation/screens/chat_history_screen.dart
lib/app/router/app_router.dart
  </files>
  <action>
**Create lib/features/chat/presentation/screens/chat_history_screen.dart:**

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:logly/features/chat/data/chat_conversation_repository.dart';
import 'package:logly/features/chat/domain/chat_conversation.dart';
import 'package:lucide_icons_flutter/lucide_icons.dart';
import 'package:intl/intl.dart';

/// Screen showing the user's conversation history.
///
/// Displays conversations sorted by most recent, with swipe-to-delete.
/// Tapping a conversation navigates back to chat screen to load it.
class ChatHistoryScreen extends ConsumerStatefulWidget {
  const ChatHistoryScreen({super.key});

  @override
  ConsumerState<ChatHistoryScreen> createState() => _ChatHistoryScreenState();
}

class _ChatHistoryScreenState extends ConsumerState<ChatHistoryScreen> {
  List<ChatConversation>? _conversations;
  bool _isLoading = true;
  String? _error;

  @override
  void initState() {
    super.initState();
    _loadConversations();
  }

  Future<void> _loadConversations() async {
    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final repository = ref.read(chatConversationRepositoryProvider);
      final conversations = await repository.getAll();
      if (mounted) {
        setState(() {
          _conversations = conversations;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _error = 'Failed to load conversations';
          _isLoading = false;
        });
      }
    }
  }

  Future<void> _deleteConversation(ChatConversation conversation) async {
    final repository = ref.read(chatConversationRepositoryProvider);
    try {
      await repository.delete(conversation.conversationId);
      if (mounted) {
        setState(() {
          _conversations?.remove(conversation);
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Failed to delete conversation')),
        );
      }
    }
  }

  void _selectConversation(ChatConversation conversation) {
    // Return the selected conversation ID to the chat screen
    context.pop(conversation.conversationId);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Chat History'),
      ),
      body: _buildBody(theme),
    );
  }

  Widget _buildBody(ThemeData theme) {
    if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (_error != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(LucideIcons.alertCircle, size: 48, color: theme.colorScheme.error),
            const SizedBox(height: 16),
            Text(_error!, style: theme.textTheme.bodyLarge),
            const SizedBox(height: 16),
            FilledButton.tonal(
              onPressed: _loadConversations,
              child: const Text('Retry'),
            ),
          ],
        ),
      );
    }

    if (_conversations == null || _conversations!.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(LucideIcons.messageSquare, size: 48, color: theme.colorScheme.onSurfaceVariant),
            const SizedBox(height: 16),
            Text(
              'No conversations yet',
              style: theme.textTheme.bodyLarge?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Start chatting to see your history here',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: _loadConversations,
      child: ListView.builder(
        itemCount: _conversations!.length,
        itemBuilder: (context, index) {
          final conversation = _conversations![index];
          return _ConversationTile(
            conversation: conversation,
            onTap: () => _selectConversation(conversation),
            onDelete: () => _deleteConversation(conversation),
          );
        },
      ),
    );
  }
}

class _ConversationTile extends StatelessWidget {
  const _ConversationTile({
    required this.conversation,
    required this.onTap,
    required this.onDelete,
  });

  final ChatConversation conversation;
  final VoidCallback onTap;
  final VoidCallback onDelete;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final dateFormat = DateFormat.yMMMd();
    final timeFormat = DateFormat.jm();

    return Dismissible(
      key: Key(conversation.conversationId),
      direction: DismissDirection.endToStart,
      background: Container(
        color: theme.colorScheme.error,
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.only(right: 16),
        child: Icon(LucideIcons.trash2, color: theme.colorScheme.onError),
      ),
      confirmDismiss: (direction) async {
        return await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('Delete conversation?'),
            content: const Text('This action cannot be undone.'),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(false),
                child: const Text('Cancel'),
              ),
              TextButton(
                onPressed: () => Navigator.of(context).pop(true),
                child: Text('Delete', style: TextStyle(color: theme.colorScheme.error)),
              ),
            ],
          ),
        );
      },
      onDismissed: (_) => onDelete(),
      child: ListTile(
        title: Text(
          conversation.title ?? 'Untitled conversation',
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
        subtitle: Text(
          '${dateFormat.format(conversation.updatedAt)} at ${timeFormat.format(conversation.updatedAt)}',
          style: theme.textTheme.bodySmall?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
        trailing: Icon(LucideIcons.chevronRight, color: theme.colorScheme.onSurfaceVariant),
        onTap: onTap,
      ),
    );
  }
}
```

**Update lib/app/router/app_router.dart:**

Add route for the history screen. Add to the GoRouter routes:

```dart
// Import at top
import 'package:logly/features/chat/presentation/screens/chat_history_screen.dart';

// Add route (adjust path and name to match existing patterns)
GoRoute(
  path: '/chat/history',
  name: 'chatHistory',
  builder: (context, state) => const ChatHistoryScreen(),
),
```

If using go_router_builder, add the route type and regenerate.
  </action>
  <verify>Files exist and route is registered in app_router.dart</verify>
  <done>ChatHistoryScreen shows conversations with delete and selection, route registered</done>
</task>

<task type="auto">
  <name>Task 4: Integrate everything into chat screen</name>
  <files>
lib/features/chat/presentation/screens/chat_screen.dart
lib/features/chat/presentation/providers/chat_ui_provider.dart
  </files>
  <action>
**Update lib/features/chat/presentation/screens/chat_screen.dart:**

1. Import new widgets and screens:
```dart
import 'package:logly/features/chat/presentation/widgets/follow_up_chips.dart';
import 'package:logly/features/chat/data/chat_conversation_repository.dart';
import 'package:logly/features/chat/data/chat_message_repository.dart';
import 'package:lucide_icons_flutter/lucide_icons.dart';
```

2. **Add History button to AppBar actions:**
```dart
AppBar(
  title: const Text('Chat'),
  actions: [
    IconButton(
      icon: const Icon(LucideIcons.history),
      tooltip: 'Chat History',
      onPressed: _openHistory,
    ),
    IconButton(
      icon: const Icon(LucideIcons.squarePen),
      tooltip: 'New Chat',
      onPressed: _startNewChat,
    ),
  ],
),
```

3. **Add handler methods:**
```dart
Future<void> _openHistory() async {
  final selectedConversationId = await context.push<String>('/chat/history');
  if (selectedConversationId != null && mounted) {
    await _loadConversation(selectedConversationId);
  }
}

void _startNewChat() {
  // Clear current messages from UI
  ref.read(chatUiStateProvider).clear();
  // Reset stream state and conversation ID
  ref.read(chatStreamStateProvider.notifier).startNewConversation();
}

Future<void> _loadConversation(String conversationId) async {
  // Clear current messages
  ref.read(chatUiStateProvider).clear();

  // Set the conversation ID for follow-up chaining
  ref.read(chatStreamStateProvider.notifier).setConversationId(conversationId);

  // Load messages from Supabase
  final messageRepo = ref.read(chatMessageRepositoryProvider);
  final messages = await messageRepo.getByConversation(conversationId);

  // Load conversation to get follow-up IDs
  final convRepo = ref.read(chatConversationRepositoryProvider);
  final conversation = await convRepo.getById(conversationId);

  // Add messages to UI controller
  final controller = ref.read(chatUiStateProvider);
  final user = ref.read(currentUserProvider);
  final currentUserId = user?.id ?? 'user';

  for (final msg in messages) {
    final uiMessage = _domainToUiMessage(msg, currentUserId);
    await controller.insertMessage(uiMessage);
  }

  // If last message is from assistant and has follow-ups, show them
  if (messages.isNotEmpty && messages.last.role == ChatMessageRole.assistant) {
    final lastMetadata = messages.last.metadata;
    if (lastMetadata?.followUpSuggestions != null && lastMetadata!.followUpSuggestions!.isNotEmpty) {
      // Update state with follow-up suggestions for display
      ref.read(chatStreamStateProvider.notifier).state =
        ref.read(chatStreamStateProvider).copyWith(
          followUpSuggestions: lastMetadata.followUpSuggestions!,
        );
    }
  }
}

Message _domainToUiMessage(ChatMessage msg, String currentUserId) {
  final authorId = msg.role == ChatMessageRole.user ? currentUserId : 'ai';

  if (msg.role == ChatMessageRole.system) {
    return SystemMessage(
      id: msg.messageId,
      text: msg.content,
      createdAt: msg.createdAt,
    );
  }

  return TextMessage(
    id: msg.messageId,
    authorId: authorId,
    text: msg.content,
    createdAt: msg.createdAt,
    metadata: msg.metadata != null ? {
      'followUpSuggestions': msg.metadata!.followUpSuggestions,
      'steps': msg.metadata!.steps,
    } : null,
  );
}
```

4. **DO NOT auto-load conversation on initState.** Per user decision, show empty state on open. Remove any `_loadExistingConversation()` calls from initState.

5. **Add follow-up chips after AI messages.** In the message list builder, after the AI message text:
```dart
// Show follow-up chips after the last AI message
final streamState = ref.watch(chatStreamStateProvider);
if (streamState.followUpSuggestions.isNotEmpty &&
    streamState.status == ChatConnectionStatus.completed) {
  // Check if this is the last message
  FollowUpChips(
    suggestions: streamState.followUpSuggestions,
    onTap: (question) {
      // Clear suggestions when sending
      _handleSendMessage(question);
    },
  ),
}
```

6. **Clear follow-up suggestions when sending a message:**
```dart
void _handleSendMessage(String message) {
  // Clear follow-up suggestions when user sends a message
  ref.read(chatStreamStateProvider.notifier).state =
    ref.read(chatStreamStateProvider).copyWith(
      followUpSuggestions: [],
    );

  // ... existing send logic
}
```

**Update lib/features/chat/presentation/providers/chat_ui_provider.dart:**

If needed, expose a method to clear all messages or ensure the clear() method exists on the chat UI controller.
  </action>
  <verify>Run `fvm flutter analyze` - should pass. History and New Chat buttons should appear in header.</verify>
  <done>Chat screen has History button, New Chat button, follow-up chips, empty state on open (no auto-load)</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Phase 4 functionality: empty state on open, multi-turn conversations with backend persistence, follow-up suggestion chips, history list with selection, and new chat button</what-built>
  <how-to-verify>
1. Empty state test:
   - Open the app and navigate to the chat screen
   - Verify: Empty state shows dynamic prompts (NOT previous conversation)
   - Verify: Header has History button (clock icon) and New Chat button (square+pen icon)
   - Tap a starter question - should send immediately

2. Conversation flow test:
   - Send a question like "What did I log this week?"
   - Wait for the AI response to complete
   - Verify: 2-3 follow-up suggestion chips appear below the AI response
   - Verify: Tapping a follow-up chip sends that question and clears chips
   - Verify: The AI's follow-up answer shows context from the first question

3. History button test:
   - After having at least one conversation, tap the History button
   - Verify: History screen shows list of conversations with titles and dates
   - Verify: Conversations sorted by most recent first
   - Tap a conversation - should return to chat screen and load that conversation's messages
   - Verify: Follow-up suggestions appear if the last message was from AI

4. New Chat button test:
   - While viewing a loaded conversation, tap the New Chat button
   - Verify: Messages are cleared
   - Verify: Empty state with starter questions appears
   - Send a new question
   - Verify: A new conversation is created (not appended to old one)

5. Swipe to delete test:
   - Open history screen
   - Swipe left on a conversation
   - Verify: Delete confirmation dialog appears
   - Confirm delete
   - Verify: Conversation is removed from list

6. Multi-turn context test:
   - Ask "How many times did I exercise this week?"
   - After response, tap a follow-up or ask "What about last week?"
   - Verify: AI response compares to the previous week (shows it understood context)

7. App reopen test:
   - Complete a conversation
   - Force-quit the app (not just background)
   - Reopen the app and navigate to chat
   - Verify: Empty state shows (NOT previous conversation)
   - Tap History button and select the previous conversation
   - Verify: Messages load correctly with follow-up chips if applicable
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. Done event handling: grep "conversationId" lib/features/chat/application/chat_service.dart
2. New Chat method: grep "startNewConversation" lib/features/chat/presentation/providers/chat_stream_provider.dart
3. Follow-up chips widget: ls lib/features/chat/presentation/widgets/follow_up_chips.dart
4. History screen exists: ls lib/features/chat/presentation/screens/chat_history_screen.dart
5. History button in screen: grep "history" lib/features/chat/presentation/screens/chat_screen.dart
6. New Chat button: grep "squarePen\|New Chat" lib/features/chat/presentation/screens/chat_screen.dart
7. No auto-load on init: grep -v "loadExisting\|initState.*load" lib/features/chat/presentation/screens/chat_screen.dart
8. Codegen passes: `fvm dart run build_runner build --delete-conflicting-outputs`
9. No analyzer errors: `fvm flutter analyze`
</verification>

<success_criteria>
- Empty state shown on chat screen open (NOT auto-load)
- Follow-up events from done event update state with suggestions
- FollowUpChips widget displays after AI responses
- Tapping a chip sends the follow-up question and clears chips
- History button opens conversation list
- Selecting a conversation loads its messages
- New Chat button clears messages and resets conversation
- Swipe-to-delete works on history items
- Multi-turn context works via conversationId from backend
- Human verification confirms all flows work end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/04-conversation-discovery/04-04-SUMMARY.md`
</output>
