---
phase: 04-conversation-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260203000000_chat_history.sql
  - lib/features/chat/domain/chat_conversation.dart
  - lib/features/chat/domain/chat_message.dart
autonomous: true

must_haves:
  truths:
    - "Chat conversations table exists in Supabase with RLS"
    - "Chat messages table exists in Supabase with RLS"
    - "Domain models serialize to/from JSON correctly"
  artifacts:
    - path: "supabase/migrations/20260203000000_chat_history.sql"
      provides: "Supabase tables with RLS policies"
      contains: "CREATE TABLE public.chat_conversations"
    - path: "lib/features/chat/domain/chat_conversation.dart"
      provides: "Freezed conversation domain model"
      contains: "@freezed"
    - path: "lib/features/chat/domain/chat_message.dart"
      provides: "Freezed message domain model"
      contains: "@freezed"
  key_links:
    - from: "lib/features/chat/domain/chat_conversation.dart"
      to: "supabase/migrations/20260203000000_chat_history.sql"
      via: "JSON field mapping"
      pattern: "conversation_id"
    - from: "lib/features/chat/domain/chat_message.dart"
      to: "supabase/migrations/20260203000000_chat_history.sql"
      via: "JSON field mapping"
      pattern: "message_id"
---

<objective>
Create the data foundation for chat history: Supabase tables with RLS policies and Freezed domain models for Flutter.

Purpose: Enable chat conversations and messages to be stored server-side in Supabase. Per user decision, there is NO local Drift cache - all data lives in Supabase only.
Output: SQL migration and Freezed domain models. Backend (edge function) will own persistence; client will only read.
</objective>

<execution_context>
@/Users/robsnider/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robsnider/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-conversation-discovery/04-CONTEXT.md

# Existing patterns
@lib/features/chat/domain/chat_stream_state.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase migration for chat history tables</name>
  <files>supabase/migrations/20260203000000_chat_history.sql</files>
  <action>
Create a Supabase migration with two tables:

**chat_conversations table:**
- conversation_id: uuid PRIMARY KEY DEFAULT gen_random_uuid()
- user_id: uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
- title: text (nullable, for first user message snippet)
- last_response_id: text (nullable, OpenAI response ID for follow-up chaining)
- last_conversion_id: text (nullable, SQL agent conversion ID for context)
- created_at: timestamptz NOT NULL DEFAULT now()
- updated_at: timestamptz NOT NULL DEFAULT now()

**chat_messages table:**
- message_id: uuid PRIMARY KEY DEFAULT gen_random_uuid()
- conversation_id: uuid NOT NULL REFERENCES public.chat_conversations(conversation_id) ON DELETE CASCADE
- role: text NOT NULL CHECK (role IN ('user', 'assistant', 'system'))
- content: text NOT NULL
- metadata: jsonb (nullable, for follow-up suggestions, step info)
- created_at: timestamptz NOT NULL DEFAULT now()

**RLS policies:**
- Enable RLS on both tables
- chat_conversations: "Users can manage own conversations" - FOR ALL USING (user_id = auth.uid())
- chat_messages: "Users can manage own messages" - FOR ALL USING subquery on conversation ownership
- service_role bypass for edge function writes

**Indexes:**
- idx_chat_conversations_user ON chat_conversations(user_id, updated_at DESC)
- idx_chat_messages_conversation ON chat_messages(conversation_id, created_at)
  </action>
  <verify>File exists at supabase/migrations/20260203000000_chat_history.sql with both CREATE TABLE statements, RLS policies, and indexes</verify>
  <done>Migration file ready for deployment, creates chat_conversations and chat_messages tables with proper RLS</done>
</task>

<task type="auto">
  <name>Task 2: Create Freezed domain models for conversations and messages</name>
  <files>
lib/features/chat/domain/chat_conversation.dart
lib/features/chat/domain/chat_message.dart
  </files>
  <action>
**Create lib/features/chat/domain/chat_conversation.dart:**
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'chat_conversation.freezed.dart';
part 'chat_conversation.g.dart';

/// Domain model for a chat conversation.
///
/// Maps to Supabase `chat_conversations` table.
/// Stores follow-up IDs for multi-turn conversation context.
@freezed
abstract class ChatConversation with _$ChatConversation {
  const factory ChatConversation({
    @JsonKey(name: 'conversation_id') required String conversationId,
    @JsonKey(name: 'user_id') required String userId,
    String? title,
    @JsonKey(name: 'last_response_id') String? lastResponseId,
    @JsonKey(name: 'last_conversion_id') String? lastConversionId,
    @JsonKey(name: 'created_at') required DateTime createdAt,
    @JsonKey(name: 'updated_at') required DateTime updatedAt,
  }) = _ChatConversation;

  factory ChatConversation.fromJson(Map<String, dynamic> json) =>
      _$ChatConversationFromJson(json);
}
```

**Create lib/features/chat/domain/chat_message.dart:**
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'chat_message.freezed.dart';
part 'chat_message.g.dart';

/// Role of a chat message sender.
enum ChatMessageRole {
  user,
  assistant,
  system,
}

/// Metadata for an assistant message.
///
/// Contains follow-up suggestions and step information.
@freezed
abstract class ChatMessageMetadata with _$ChatMessageMetadata {
  const factory ChatMessageMetadata({
    @JsonKey(name: 'follow_up_suggestions') List<String>? followUpSuggestions,
    List<String>? steps,
  }) = _ChatMessageMetadata;

  factory ChatMessageMetadata.fromJson(Map<String, dynamic> json) =>
      _$ChatMessageMetadataFromJson(json);
}

/// Domain model for a persisted chat message.
///
/// Maps to Supabase `chat_messages` table.
/// Metadata stores follow-up suggestions for assistant messages.
@freezed
abstract class ChatMessage with _$ChatMessage {
  const factory ChatMessage({
    @JsonKey(name: 'message_id') required String messageId,
    @JsonKey(name: 'conversation_id') required String conversationId,
    required ChatMessageRole role,
    required String content,
    ChatMessageMetadata? metadata,
    @JsonKey(name: 'created_at') required DateTime createdAt,
  }) = _ChatMessage;

  factory ChatMessage.fromJson(Map<String, dynamic> json) =>
      _$ChatMessageFromJson(json);
}
```

Use @JsonKey annotations to match Supabase snake_case column names.
  </action>
  <verify>Run `fvm dart run build_runner build --delete-conflicting-outputs` - should generate .freezed.dart and .g.dart files for both models</verify>
  <done>Domain models ChatConversation and ChatMessage exist with fromJson/toJson, codegen passes</done>
</task>

</tasks>

<verification>
1. Migration file exists: `ls supabase/migrations/20260203000000_chat_history.sql`
2. Domain models exist: `ls lib/features/chat/domain/chat_conversation.dart lib/features/chat/domain/chat_message.dart`
3. Codegen passes: `fvm dart run build_runner build --delete-conflicting-outputs` exits 0
4. No analyzer errors: `fvm flutter analyze lib/features/chat/domain`
</verification>

<success_criteria>
- Supabase migration creates chat_conversations and chat_messages tables with RLS
- ChatConversation and ChatMessage Freezed models serialize correctly
- All generated files present (.freezed.dart, .g.dart)
- Zero analyzer errors
- NO Drift tables created (per user decision: no local cache)
</success_criteria>

<output>
After completion, create `.planning/phases/04-conversation-discovery/04-01-SUMMARY.md`
</output>
