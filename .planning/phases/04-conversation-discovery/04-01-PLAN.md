---
phase: 04-conversation-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/20260203000000_chat_history.sql
  - lib/app/database/tables/chat_conversations.dart
  - lib/app/database/tables/chat_messages.dart
  - lib/app/database/drift_database.dart
  - lib/features/chat/domain/chat_conversation.dart
  - lib/features/chat/domain/chat_message.dart
autonomous: true

must_haves:
  truths:
    - "Chat conversations table exists in Supabase with RLS"
    - "Chat messages table exists in Supabase with RLS"
    - "Drift can cache conversations and messages locally"
    - "Domain models serialize to/from JSON correctly"
  artifacts:
    - path: "supabase/migrations/20260203000000_chat_history.sql"
      provides: "Supabase tables with RLS policies"
      contains: "CREATE TABLE public.chat_conversations"
    - path: "lib/app/database/tables/chat_conversations.dart"
      provides: "Drift table for local conversation cache"
      contains: "class ChatConversations extends Table"
    - path: "lib/app/database/tables/chat_messages.dart"
      provides: "Drift table for local message cache"
      contains: "class ChatMessages extends Table"
    - path: "lib/features/chat/domain/chat_conversation.dart"
      provides: "Freezed conversation domain model"
      contains: "@freezed"
    - path: "lib/features/chat/domain/chat_message.dart"
      provides: "Freezed message domain model"
      contains: "@freezed"
  key_links:
    - from: "lib/app/database/drift_database.dart"
      to: "tables/chat_conversations.dart"
      via: "@DriftDatabase import"
      pattern: "ChatConversations"
    - from: "lib/app/database/drift_database.dart"
      to: "tables/chat_messages.dart"
      via: "@DriftDatabase import"
      pattern: "ChatMessages"
---

<objective>
Create the data foundation for chat history persistence: Supabase tables with RLS policies, Drift tables for local caching, and Freezed domain models.

Purpose: Enable chat conversations and messages to be stored server-side (Supabase) and cached locally (Drift) for offline viewing and fast loads.
Output: SQL migration, Drift tables, Freezed domain models, and updated database with schema version 2.
</objective>

<execution_context>
@/Users/robsnider/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robsnider/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-conversation-discovery/04-RESEARCH.md

# Existing patterns
@lib/app/database/drift_database.dart
@lib/app/database/tables/cached_data.dart
@lib/features/chat/domain/chat_stream_state.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase migration for chat history tables</name>
  <files>supabase/migrations/20260203000000_chat_history.sql</files>
  <action>
Create a Supabase migration with two tables following the schema from RESEARCH.md:

**chat_conversations table:**
- conversation_id: uuid PRIMARY KEY DEFAULT gen_random_uuid()
- user_id: uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
- title: text (nullable, for first user message or AI-generated)
- last_response_id: text (nullable, OpenAI response ID for follow-up chaining)
- last_conversion_id: text (nullable, SQL agent conversion ID for context)
- created_at: timestamptz NOT NULL DEFAULT now()
- updated_at: timestamptz NOT NULL DEFAULT now()

**chat_messages table:**
- message_id: uuid PRIMARY KEY DEFAULT gen_random_uuid()
- conversation_id: uuid NOT NULL REFERENCES public.chat_conversations(conversation_id) ON DELETE CASCADE
- role: text NOT NULL CHECK (role IN ('user', 'assistant', 'system'))
- content: text NOT NULL
- metadata: jsonb (nullable, for step info, follow-up suggestions)
- created_at: timestamptz NOT NULL DEFAULT now()

**RLS policies:**
- Enable RLS on both tables
- chat_conversations: "Users can manage own conversations" - FOR ALL USING (user_id = auth.uid())
- chat_messages: "Users can manage own messages" - FOR ALL USING subquery on conversation ownership

**Indexes:**
- idx_chat_conversations_user ON chat_conversations(user_id, updated_at DESC)
- idx_chat_messages_conversation ON chat_messages(conversation_id, created_at)
  </action>
  <verify>File exists at supabase/migrations/20260203000000_chat_history.sql with both CREATE TABLE statements, RLS policies, and indexes</verify>
  <done>Migration file ready for deployment, creates chat_conversations and chat_messages tables with proper RLS</done>
</task>

<task type="auto">
  <name>Task 2: Create Drift tables for local chat caching</name>
  <files>
lib/app/database/tables/chat_conversations.dart
lib/app/database/tables/chat_messages.dart
lib/app/database/drift_database.dart
  </files>
  <action>
**Create lib/app/database/tables/chat_conversations.dart:**
```dart
import 'package:drift/drift.dart';

/// Local cache of chat conversations.
class ChatConversations extends Table {
  TextColumn get conversationId => text()();
  TextColumn get userId => text()();
  TextColumn get title => text().nullable()();
  TextColumn get lastResponseId => text().nullable()();
  TextColumn get lastConversionId => text().nullable()();
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get updatedAt => dateTime()();
  TextColumn get syncStatus => text().withDefault(const Constant('synced'))();

  @override
  Set<Column> get primaryKey => {conversationId};
}
```

**Create lib/app/database/tables/chat_messages.dart:**
```dart
import 'package:drift/drift.dart';

/// Local cache of chat messages.
class ChatMessages extends Table {
  TextColumn get messageId => text()();
  TextColumn get conversationId => text()();
  TextColumn get role => text()(); // 'user', 'assistant', 'system'
  TextColumn get content => text()();
  TextColumn get metadata => text().nullable()(); // JSON string
  DateTimeColumn get createdAt => dateTime()();
  TextColumn get syncStatus => text().withDefault(const Constant('synced'))();

  @override
  Set<Column> get primaryKey => {messageId};
}
```

**Update lib/app/database/drift_database.dart:**
1. Import the new tables
2. Add to @DriftDatabase tables list: [CachedData, ChatConversations, ChatMessages]
3. Increment schemaVersion from 1 to 2
4. Add onUpgrade migration:
```dart
onUpgrade: (Migrator m, int from, int to) async {
  if (from < 2) {
    await m.createTable(chatConversations);
    await m.createTable(chatMessages);
  }
},
```

Do NOT add CRUD methods yet - those come in Plan 03 with the persistence service.
  </action>
  <verify>Run `fvm dart run build_runner build --delete-conflicting-outputs` - should generate drift_database.g.dart with ChatConversationsData and ChatMessagesData classes</verify>
  <done>Drift tables defined, schema version incremented to 2 with migration, codegen passes</done>
</task>

<task type="auto">
  <name>Task 3: Create Freezed domain models for conversations and messages</name>
  <files>
lib/features/chat/domain/chat_conversation.dart
lib/features/chat/domain/chat_message.dart
  </files>
  <action>
**Create lib/features/chat/domain/chat_conversation.dart:**
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'chat_conversation.freezed.dart';
part 'chat_conversation.g.dart';

/// Domain model for a chat conversation.
///
/// Maps to both Supabase `chat_conversations` table and Drift local cache.
/// Stores follow-up IDs for multi-turn conversation context.
@freezed
abstract class ChatConversation with _$ChatConversation {
  const factory ChatConversation({
    required String conversationId,
    required String userId,
    String? title,
    String? lastResponseId,
    String? lastConversionId,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) = _ChatConversation;

  factory ChatConversation.fromJson(Map<String, dynamic> json) =>
      _$ChatConversationFromJson(json);
}
```

**Create lib/features/chat/domain/chat_message.dart:**
```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'chat_message.freezed.dart';
part 'chat_message.g.dart';

/// Role of a chat message sender.
enum ChatMessageRole {
  user,
  assistant,
  system,
}

/// Domain model for a persisted chat message.
///
/// Maps to both Supabase `chat_messages` table and Drift local cache.
/// Metadata stores step info and follow-up suggestions for assistant messages.
@freezed
abstract class ChatMessage with _$ChatMessage {
  const factory ChatMessage({
    required String messageId,
    required String conversationId,
    required ChatMessageRole role,
    required String content,
    Map<String, dynamic>? metadata,
    required DateTime createdAt,
  }) = _ChatMessage;

  factory ChatMessage.fromJson(Map<String, dynamic> json) =>
      _$ChatMessageFromJson(json);
}
```

Use @JsonKey annotations if needed to match Supabase snake_case column names (conversation_id, message_id, etc.). Check the existing chat_stream_state.dart for the project's JSON key conventions.
  </action>
  <verify>Run `fvm dart run build_runner build --delete-conflicting-outputs` - should generate .freezed.dart and .g.dart files for both models</verify>
  <done>Domain models ChatConversation and ChatMessage exist with fromJson/toJson, codegen passes</done>
</task>

</tasks>

<verification>
1. Migration file exists: `ls supabase/migrations/20260203000000_chat_history.sql`
2. Drift tables exist: `ls lib/app/database/tables/chat_*.dart`
3. Domain models exist: `ls lib/features/chat/domain/chat_conversation.dart lib/features/chat/domain/chat_message.dart`
4. Codegen passes: `fvm dart run build_runner build --delete-conflicting-outputs` exits 0
5. No analyzer errors: `fvm flutter analyze lib/app/database lib/features/chat/domain`
</verification>

<success_criteria>
- Supabase migration creates chat_conversations and chat_messages tables with RLS
- Drift schema version 2 with migration creates local cache tables
- ChatConversation and ChatMessage Freezed models serialize correctly
- All generated files present (.freezed.dart, .g.dart)
- Zero analyzer errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-conversation-discovery/04-01-SUMMARY.md`
</output>
