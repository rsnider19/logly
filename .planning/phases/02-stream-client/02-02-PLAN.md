---
phase: 02-stream-client
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - lib/features/chat/application/typewriter_buffer.dart
  - lib/features/chat/application/chat_service.dart
  - lib/features/chat/presentation/providers/chat_stream_provider.dart
autonomous: true

must_haves:
  truths:
    - "Text deltas from the SSE stream are emitted to the UI one character at a time at 5ms intervals (typewriter effect)"
    - "After the done event, remaining buffered text drains at 1ms per character"
    - "If no SSE event arrives for 30 seconds, the connection is treated as dead and retried once silently"
    - "If retry also fails, a user-friendly error is surfaced"
    - "New questions are blocked while a response is still streaming"
    - "responseId and conversionId from the stream are captured and available for follow-up questions"
  artifacts:
    - path: "lib/features/chat/application/typewriter_buffer.dart"
      provides: "TypewriterBuffer class with 5ms normal / 1ms drain character emission"
      contains: "class TypewriterBuffer"
    - path: "lib/features/chat/application/chat_service.dart"
      provides: "ChatService with stall detection, auto-retry, and event routing"
      contains: "class ChatService"
    - path: "lib/features/chat/presentation/providers/chat_stream_provider.dart"
      provides: "Riverpod notifier exposing ChatStreamState to the UI"
      contains: "ChatStreamStateNotifier"
  key_links:
    - from: "lib/features/chat/application/chat_service.dart"
      to: "lib/features/chat/data/chat_repository.dart"
      via: "calls repository.sendQuestion()"
      pattern: "_repository\\.sendQuestion"
    - from: "lib/features/chat/application/chat_service.dart"
      to: "lib/features/chat/application/typewriter_buffer.dart"
      via: "routes text_delta events to typewriter buffer"
      pattern: "_typewriter.*addDelta|TypewriterBuffer"
    - from: "lib/features/chat/presentation/providers/chat_stream_provider.dart"
      to: "lib/features/chat/application/chat_service.dart"
      via: "notifier calls service.sendQuestion and listens to state updates"
      pattern: "_service\\.sendQuestion|chatServiceProvider"
    - from: "lib/features/chat/presentation/providers/chat_stream_provider.dart"
      to: "lib/features/chat/domain/chat_stream_state.dart"
      via: "state type is ChatStreamState"
      pattern: "ChatStreamState"
---

<objective>
Build the typewriter text buffer, chat service with stall detection and retry logic, and the Riverpod state notifier that exposes the chat stream to the UI layer.

Purpose: This is the business logic that transforms raw `Stream<ChatEvent>` from the repository into a smooth, typewriter-animated `ChatStreamState` the UI can render. It handles all connection lifecycle concerns (stall detection, auto-retry, blocking concurrent requests) so the UI layer in Phase 3 just watches state.

Output: 3 source files in `lib/features/chat/application/` and `lib/features/chat/presentation/providers/`, plus generated `.g.dart` files.
</objective>

<execution_context>
@/Users/robsnider/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robsnider/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-stream-client/02-CONTEXT.md
@.planning/phases/02-stream-client/02-RESEARCH.md
@.planning/phases/02-stream-client/02-01-SUMMARY.md
@lib/features/chat/domain/chat_event.dart
@lib/features/chat/domain/chat_stream_state.dart
@lib/features/chat/domain/chat_exception.dart
@lib/features/chat/data/chat_repository.dart
@lib/features/home/application/home_service.dart
@lib/core/providers/logger_provider.dart
@lib/core/services/logger_service.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Typewriter buffer and chat service</name>
  <files>
    lib/features/chat/application/typewriter_buffer.dart
    lib/features/chat/application/chat_service.dart
  </files>
  <action>
Create `lib/features/chat/application/` directory and two files:

**typewriter_buffer.dart** -- Standalone class that accepts text deltas and emits characters one-by-one at a controlled rate.
- Class `TypewriterBuffer` with:
  - Constructor parameters: `Duration normalInterval = const Duration(milliseconds: 5)` and `Duration drainInterval = const Duration(milliseconds: 1)`.
  - Private fields: `StringBuffer _pendingBuffer` (incoming text not yet emitted), `StringBuffer _emittedBuffer` (text already dripped to UI), `StreamController<String>.broadcast() _controller`, `Timer? _timer`, `bool _isDraining = false`, `bool _isDone = false`.
  - `Stream<String> get stream` -- the broadcast stream from `_controller`. Each emission is the FULL accumulated text so far (not just the new character). This makes it easy for the UI to just display the latest emission.
  - `String get currentText` -- returns `_emittedBuffer.toString()`.
  - `String get fullText` -- returns `_emittedBuffer.toString() + _pendingBuffer.toString()`. This gives the complete text including buffered-but-not-yet-displayed characters.
  - `bool get isComplete` -- `_isDone && _pendingBuffer.isEmpty`.
  - `void addDelta(String delta)` -- appends to `_pendingBuffer`, calls `_ensureTimerRunning()`.
  - `void markDone()` -- sets `_isDone = true`, `_isDraining = true`, cancels existing timer, nulls it, calls `_ensureTimerRunning()` to restart with drain interval.
  - `void _ensureTimerRunning()` -- if timer is already running or buffer is empty, return. Otherwise start `Timer.periodic` with the appropriate interval (`_isDraining ? drainInterval : normalInterval`). Each tick: if buffer empty, cancel timer, null it, and if `_isDone`, close the controller and return. Otherwise, extract first character from `_pendingBuffer` (convert to string, take `[0]`, clear buffer and write `substring(1)`), append to `_emittedBuffer`, emit `_emittedBuffer.toString()` via `_controller.add()`.
  - `void dispose()` -- cancel timer, null it, close controller if not already closed.
- IMPORTANT: Filter empty deltas BEFORE calling `addDelta` (done by the caller, not inside this class -- keep it simple).
- IMPORTANT: Use `StringBuffer` operations carefully. To extract the first char and keep the rest: `final str = _pendingBuffer.toString(); _pendingBuffer.clear(); _pendingBuffer.write(str.substring(1));`. This is necessary because `StringBuffer` has no `removeFirst` method.

**chat_service.dart** -- Business logic layer orchestrating repository, stall detection, retry, and typewriter buffering.
- Class `ChatService` with constructor: `ChatService(this._repository, this._logger)`.
- Private fields: `ChatRepository _repository`, `LoggerService _logger`.
- The service is stateless for stream management -- it creates a new `TypewriterBuffer` per request and returns results via callbacks/streams. The Riverpod notifier (Plan 02 Task 2) manages the stateful lifecycle.
- Key method: `Future<void> sendQuestion({required String query, String? previousResponseId, String? previousConversionId, required void Function(ChatStreamState) onStateUpdate})`:
  1. Emit `ChatStreamState(status: ChatConnectionStatus.connecting)`.
  2. Call `_executeStream(query, previousResponseId, previousConversionId, onStateUpdate, isRetry: false)`.
  3. Catch `ChatException` -- if not yet retried, emit state with `isRetrying: true`, call `_executeStream` again with `isRetry: true`. If retry also throws, emit error state with `exception.message`.
  4. Catch generic `Exception` -- same retry logic, wrap in `ChatConnectionException`.

- Private method `Future<void> _executeStream(String query, String? previousResponseId, String? previousConversionId, void Function(ChatStreamState) onStateUpdate, {required bool isRetry})`:
  1. Create fresh `TypewriterBuffer`.
  2. Initialize tracking variables: `String fullText = ''`, `String? responseId`, `String? conversionId`, `String? currentStepName`, `String? currentStepStatus`, `List<ChatCompletedStep> completedSteps = []`.
  3. Get `Stream<ChatEvent>` from `_repository.sendQuestion(...)`.
  4. Wrap with stall detection: `.timeout(const Duration(seconds: 30), onTimeout: (sink) { sink.addError(const ChatStallException()); sink.close(); })`.
  5. Listen to the stream event-by-event with `await for`:
     - `ChatStepEvent`: Update `currentStepName` and `currentStepStatus`. If `status == 'complete'`, add to `completedSteps` and clear `currentStepName`/`currentStepStatus`. Emit state immediately (no typewriter delay for steps).
     - `ChatTextDeltaEvent`: If `delta.isNotEmpty`, append delta to `fullText`, call `typewriter.addDelta(delta)`. Update status to `streaming` if not already. Emit state with updated `fullText`.
     - `ChatResponseIdEvent`: Store `responseId`. Emit state.
     - `ChatConversionIdEvent`: Store `conversionId`. Emit state.
     - `ChatErrorEvent`: Throw `ChatConnectionException(event.message)` to trigger retry logic in the outer method.
     - `ChatDoneEvent`: Call `typewriter.markDone()`. Cancel stall detection (it's implicit -- we exit the `await for` loop). Update status to `completing`.
  6. After the `await for` loop completes, listen to `typewriter.stream` and emit state updates with `displayText` from the typewriter. When the typewriter stream closes (all characters drained), emit final state with `status: completed`.
  7. Dispose the typewriter in a `finally` block.

- The `onStateUpdate` callback approach lets the notifier control state emission. Each call passes a new `ChatStreamState` with all current values.

- Provider at bottom: `@Riverpod(keepAlive: true) ChatService chatService(Ref ref)` watching `chatRepositoryProvider` and `loggerProvider`.
- Include `part 'chat_service.g.dart';`.

CRITICAL implementation notes:
- Cancel the stall timeout when `done` is received (by breaking out of the `await for` loop). Do NOT let it fire during typewriter drain. See RESEARCH.md Pitfall 2.
- The typewriter `stream` listener should update `displayText` in state while keeping `fullText` as the complete accumulated text.
- Empty `text_delta` events MUST be filtered (check `delta.isNotEmpty`) before adding to typewriter buffer. See RESEARCH.md Pitfall 6.
  </action>
  <verify>
1. `fvm dart run build_runner build --delete-conflicting-outputs` completes without errors.
2. Generated file exists: `chat_service.g.dart`.
3. `fvm flutter analyze` reports no errors in the new files.
  </verify>
  <done>
TypewriterBuffer emits characters at 5ms/char normal rate and 1ms/char drain rate. ChatService orchestrates the full stream lifecycle: connects to repository, applies 30s stall detection, routes events to state updates and typewriter, retries once silently on failure, captures responseId and conversionId. Provider is generated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Riverpod chat stream state notifier</name>
  <files>
    lib/features/chat/presentation/providers/chat_stream_provider.dart
  </files>
  <action>
Create `lib/features/chat/presentation/providers/` directory and one file:

**chat_stream_provider.dart** -- Riverpod `Notifier` that holds `ChatStreamState` and exposes a `sendQuestion` method.
- Use `@Riverpod(keepAlive: true)` annotation. Class name: `ChatStreamStateNotifier extends _$ChatStreamStateNotifier` (following the project convention where class name is `<Name>StateNotifier` generating `<name>StateProvider`).
- `@override ChatStreamState build()` returns `const ChatStreamState()` (idle state).
- Private fields set in `build()`: store `ref.watch(chatServiceProvider)` as `_service`. No need to store the ref itself.
- Track conversation IDs as instance fields: `String? _lastResponseId`, `String? _lastConversionId`. These persist across requests for follow-up chaining.
- Method `Future<void> sendQuestion(String query) async`:
  1. Guard: if `state.status` is not `idle`, `completed`, or `error`, return early (block concurrent requests per CONTEXT.md decision).
  2. Reset display state: `state = const ChatStreamState(status: ChatConnectionStatus.connecting)`.
  3. Call `_service.sendQuestion(query: query, previousResponseId: _lastResponseId, previousConversionId: _lastConversionId, onStateUpdate: (newState) { state = newState; })`.
  4. After completion, extract `state.responseId` and `state.conversionId` into `_lastResponseId` and `_lastConversionId` for next follow-up.
  5. Catch any exception: set `state = ChatStreamState(status: ChatConnectionStatus.error, errorMessage: exception.message, responseId: _lastResponseId, conversionId: _lastConversionId)`. Preserve previous IDs so user can retry.
- Method `void resetConversation()`:
  - Sets `_lastResponseId = null`, `_lastConversionId = null`.
  - Sets `state = const ChatStreamState()` (back to idle).
  - For Phase 4 (fresh conversation start).
- `ref.onDispose()` in `build()`: (no-op for now, but placeholder comment for cleanup if needed when cancellation is added later).

- Include `part 'chat_stream_provider.g.dart';`.
- Imports: the chat service, chat stream state, chat exception, and Riverpod annotation.

After creating the file, run `fvm dart run build_runner build --delete-conflicting-outputs` to generate the provider.

Finally, run `fvm flutter analyze` to confirm the entire `lib/features/chat/` directory compiles cleanly.
  </action>
  <verify>
1. `fvm dart run build_runner build --delete-conflicting-outputs` completes without errors.
2. Generated file exists: `chat_stream_provider.g.dart`.
3. `fvm flutter analyze` reports no errors across all chat feature files.
4. The generated provider name follows the convention: `chatStreamStateProvider` (from `ChatStreamStateNotifier`).
  </verify>
  <done>
ChatStreamStateNotifier exposes `sendQuestion(query)` that blocks concurrent requests, delegates to ChatService with state callback, captures conversation IDs for follow-up chaining, and surfaces errors gracefully. The provider is `@Riverpod(keepAlive: true)` so it persists for the app session. `resetConversation()` allows starting fresh. The full data pipeline is wired: Provider -> Service -> Repository -> Edge Function.
  </done>
</task>

</tasks>

<verification>
1. All files in `lib/features/chat/` compile without errors: `fvm flutter analyze`.
2. `fvm dart run build_runner build --delete-conflicting-outputs` generates all `.g.dart` files.
3. The full data pipeline is wired: `chatStreamStateProvider` -> `ChatService` -> `ChatRepository` -> `supabase.functions.invoke('chat')`.
4. TypewriterBuffer correctly drips characters at 5ms intervals with 1ms drain after done.
5. ChatService applies 30s stall detection and one silent retry before surfacing errors.
6. ChatStreamStateNotifier blocks concurrent requests and preserves conversation IDs.
</verification>

<success_criteria>
- TypewriterBuffer emits characters at 5ms/char, switches to 1ms/char after markDone()
- TypewriterBuffer.stream emits full accumulated text (not just new char) on each tick
- TypewriterBuffer.dispose() cancels timer and closes stream controller
- ChatService wraps repository stream with 30s stall timeout
- ChatService retries once silently on ChatException or ChatStallException, then surfaces error
- ChatService routes step events instantly, text_delta to typewriter, IDs to state
- ChatService filters empty text_delta events before typewriter
- ChatStreamStateNotifier blocks sendQuestion while status is connecting/streaming/completing
- ChatStreamStateNotifier preserves responseId/conversionId across requests for follow-ups
- ChatStreamStateNotifier.resetConversation() clears IDs and returns to idle
- `fvm flutter analyze` passes clean
</success_criteria>

<output>
After completion, create `.planning/phases/02-stream-client/02-02-SUMMARY.md`
</output>
