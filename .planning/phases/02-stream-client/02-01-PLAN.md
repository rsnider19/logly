---
phase: 02-stream-client
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/features/chat/domain/chat_event.dart
  - lib/features/chat/domain/chat_stream_state.dart
  - lib/features/chat/domain/chat_exception.dart
  - lib/features/chat/data/sse_event_parser.dart
  - lib/features/chat/data/chat_repository.dart
autonomous: true

must_haves:
  truths:
    - "ChatEvent sealed class deserializes all 6 server event types (step, text_delta, response_id, conversion_id, error, done) from JSON"
    - "SseEventTransformer correctly buffers arbitrary TCP chunks and emits complete SSE event payloads"
    - "ChatRepository opens an SSE connection via supabase_flutter and yields a Stream<ChatEvent>"
    - "HTTP error status codes (401, 403, 429) map to specific typed exceptions"
  artifacts:
    - path: "lib/features/chat/domain/chat_event.dart"
      provides: "Freezed sealed ChatEvent class with 6 union variants"
      contains: "@Freezed(unionKey: 'type')"
    - path: "lib/features/chat/domain/chat_stream_state.dart"
      provides: "Freezed ChatStreamState with status enum, displayText, fullText, IDs, error"
      contains: "ChatConnectionStatus"
    - path: "lib/features/chat/domain/chat_exception.dart"
      provides: "ChatException hierarchy extending AppException"
      contains: "ChatConnectionException"
    - path: "lib/features/chat/data/sse_event_parser.dart"
      provides: "SseEventTransformer StreamTransformer that buffers chunks and splits on double-newline"
      contains: "class SseEventTransformer"
    - path: "lib/features/chat/data/chat_repository.dart"
      provides: "ChatRepository with sendQuestion returning Stream<ChatEvent>"
      contains: "Stream<ChatEvent> sendQuestion"
  key_links:
    - from: "lib/features/chat/data/chat_repository.dart"
      to: "supabase.functions.invoke('chat')"
      via: "supabase_flutter functions client"
      pattern: "functions\\.invoke.*chat"
    - from: "lib/features/chat/data/chat_repository.dart"
      to: "lib/features/chat/data/sse_event_parser.dart"
      via: "stream transform pipeline"
      pattern: "transform.*SseEventTransformer"
    - from: "lib/features/chat/data/chat_repository.dart"
      to: "lib/features/chat/domain/chat_event.dart"
      via: "JSON deserialization of SSE payloads"
      pattern: "ChatEvent\\.fromJson"
---

<objective>
Create the chat feature's domain models, SSE line-buffer parser, and repository that connects to the Phase 1 edge function.

Purpose: Establish the typed data layer that converts raw SSE bytes from the `chat` edge function into a `Stream<ChatEvent>` for the service layer to consume. This is the foundation that Plan 02 builds on.

Output: 5 source files in `lib/features/chat/` (domain models + data layer), plus generated `.freezed.dart` and `.g.dart` files from build_runner.
</objective>

<execution_context>
@/Users/robsnider/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robsnider/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-stream-client/02-CONTEXT.md
@.planning/phases/02-stream-client/02-RESEARCH.md
@supabase/functions/chat/streamHandler.ts
@lib/core/exceptions/app_exception.dart
@lib/core/providers/supabase_provider.dart
@lib/core/providers/logger_provider.dart
@lib/core/services/logger_service.dart
@lib/features/activity_catalog/domain/catalog_exception.dart
@lib/features/activity_catalog/data/activity_repository.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Domain models and exception hierarchy</name>
  <files>
    lib/features/chat/domain/chat_event.dart
    lib/features/chat/domain/chat_stream_state.dart
    lib/features/chat/domain/chat_exception.dart
  </files>
  <action>
Create the `lib/features/chat/domain/` directory and three files:

**chat_event.dart** -- Freezed sealed class modeling all 6 SSE event types from the server.
- Use `@Freezed(unionKey: 'type')` so Freezed deserializes based on the JSON `type` field.
- Add `const ChatEvent._()` private constructor for custom getters.
- 6 union variants mapping exactly to the server protocol in `streamHandler.ts`:
  - `ChatEvent.step({required String name, required String status})` with `@FreezedUnionValue('step')`
  - `ChatEvent.textDelta({required String delta})` with `@FreezedUnionValue('text_delta')`
  - `ChatEvent.responseId({required String responseId})` with `@FreezedUnionValue('response_id')`
  - `ChatEvent.conversionId({required String conversionId})` with `@FreezedUnionValue('conversion_id')`
  - `ChatEvent.error({required String message})` with `@FreezedUnionValue('error')`
  - `ChatEvent.done()` with `@FreezedUnionValue('done')`
- Include `factory ChatEvent.fromJson(Map<String, dynamic> json)` for deserialization.
- Include `part 'chat_event.freezed.dart';` and `part 'chat_event.g.dart';`.

**chat_stream_state.dart** -- Freezed state model for the chat stream lifecycle.
- `@freezed abstract class ChatStreamState with _$ChatStreamState` (standard `@freezed`, not `@Freezed(unionKey:...)` -- this is a data class, not a union).
- Fields:
  - `@Default(ChatConnectionStatus.idle) ChatConnectionStatus status`
  - `@Default('') String displayText` (typewriter-dripped text for UI)
  - `@Default('') String fullText` (complete accumulated text for copy/accessibility)
  - `String? currentStepName` (active step label)
  - `String? currentStepStatus` ("start" or "complete")
  - `@Default([]) List<ChatCompletedStep> completedSteps` (history of completed steps)
  - `String? responseId` (for follow-up chaining)
  - `String? conversionId` (for SQL context chaining)
  - `String? errorMessage` (user-friendly error)
  - `@Default(false) bool isRetrying` (silent retry in progress)
- Also define `ChatCompletedStep` as a simple Freezed class with `{required String name}`.
- Define `ChatConnectionStatus` enum in the same file:
  - `idle` (no active stream)
  - `connecting` (request sent, waiting for first event)
  - `streaming` (receiving events)
  - `completing` (done received, typewriter draining)
  - `completed` (all text emitted)
  - `error` (error state)
- Include `fromJson` factory. Include `part` directives for `.freezed.dart` and `.g.dart`.

**chat_exception.dart** -- Exception hierarchy following the `CatalogException` pattern.
- `abstract class ChatException extends AppException` with `const ChatException(super.message, [super.technicalDetails])`.
- Concrete exceptions:
  - `ChatConnectionException` -- "Unable to connect. Please try again." (takes optional technicalDetails)
  - `ChatAuthException` -- "Please sign in again to continue." (const, no params)
  - `ChatPremiumRequiredException` -- "Premium subscription required." (const, no params)
  - `ChatRateLimitException` -- "You've been busy! Try again in a few minutes." (const, no params)
  - `ChatStallException` -- "Connection stalled. Please try again." (const, no params)
- Import `app_exception.dart` from core.

After creating all three files, run `fvm dart run build_runner build --delete-conflicting-outputs` to generate the `.freezed.dart` and `.g.dart` files.
  </action>
  <verify>
1. `fvm dart run build_runner build --delete-conflicting-outputs` completes without errors.
2. Generated files exist: `chat_event.freezed.dart`, `chat_event.g.dart`, `chat_stream_state.freezed.dart`, `chat_stream_state.g.dart`.
3. `fvm flutter analyze` reports no errors in the new files.
  </verify>
  <done>
ChatEvent sealed class with 6 variants deserializes from JSON matching the server protocol. ChatStreamState models the full stream lifecycle. ChatException hierarchy provides typed errors for all known failure modes. All generated files compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: SSE event parser and chat repository</name>
  <files>
    lib/features/chat/data/sse_event_parser.dart
    lib/features/chat/data/chat_repository.dart
  </files>
  <action>
Create `lib/features/chat/data/` directory and two files:

**sse_event_parser.dart** -- A `StreamTransformerBase<String, String>` that buffers incoming UTF-8 text and emits complete SSE event payloads.
- Class `SseEventTransformer extends StreamTransformerBase<String, String>`.
- `bind()` returns `Stream.eventTransformed(stream, (sink) => _SseEventSink(sink))`.
- Inner `_SseEventSink implements EventSink<String>`:
  - Holds a `StringBuffer _buffer` and `EventSink<String> _outputSink`.
  - `add(String chunk)`: appends chunk to buffer, then calls `_processBuffer()`.
  - `_processBuffer()`: splits buffer on `'\n\n'`. All complete events (everything except the last segment) are processed: for each line starting with `'data: '`, strip the prefix and emit the JSON string via `_outputSink.add()`. The last (potentially incomplete) segment stays in the buffer.
  - `addError()`: forwards to output sink.
  - `close()`: processes any remaining buffer content the same way, then closes the output sink.
- This follows the exact pattern from RESEARCH.md Pattern 1. The key behavior: handles arbitrary TCP chunk splitting by buffering until `\n\n` delimiter is found.

**chat_repository.dart** -- Repository that opens the SSE connection and returns `Stream<ChatEvent>`.
- Class `ChatRepository` with constructor accepting `SupabaseClient` and `LoggerService` (same pattern as `ActivityRepository` but without database caching).
- Method `Stream<ChatEvent> sendQuestion({required String query, String? previousResponseId, String? previousConversionId}) async*`:
  1. Call `_supabase.functions.invoke('chat', body: {...})` with query and optional IDs (use `if` collection syntax for optional fields in the body map).
  2. Cast `response.data` as `http.ByteStream` (import `package:http/http.dart` as `http`).
  3. Transform pipeline: `byteStream.transform(const Utf8Decoder()).transform(SseEventTransformer()).map((jsonStr) => ChatEvent.fromJson(jsonDecode(jsonStr) as Map<String, dynamic>))`.
  4. `yield*` the transformed stream.
  5. Catch `FunctionException` and map status codes: 401 -> `ChatAuthException`, 403 -> `ChatPremiumRequiredException`, 429 -> `ChatRateLimitException`, other -> `ChatConnectionException`.
  6. Catch generic `Exception` -> `ChatConnectionException`.
  7. Log all errors via `_logger.e()`.
- Provider at bottom of file: `@Riverpod(keepAlive: true) ChatRepository chatRepository(Ref ref)` that watches `supabaseProvider` and `loggerProvider`.
- Include `part 'chat_repository.g.dart';`.
- Imports: `dart:convert` (for `Utf8Decoder`, `jsonDecode`), `package:http/http.dart` as `http`, `package:supabase_flutter/supabase_flutter.dart` (for `FunctionException`), `package:riverpod_annotation/riverpod_annotation.dart`, and the local domain/data files.

After creating both files, run `fvm dart run build_runner build --delete-conflicting-outputs` to generate the `.g.dart` for the repository provider.
  </action>
  <verify>
1. `fvm dart run build_runner build --delete-conflicting-outputs` completes without errors.
2. Generated file exists: `chat_repository.g.dart`.
3. `fvm flutter analyze` reports no errors in the new files.
4. Quick sanity: the repository's `sendQuestion` method compiles and the Riverpod provider is generated.
  </verify>
  <done>
SseEventTransformer correctly buffers SSE chunks and emits complete JSON payloads. ChatRepository connects to the `chat` edge function via `supabase_flutter`, pipes the ByteStream through UTF-8 decode -> SSE parse -> ChatEvent deserialization, and returns `Stream<ChatEvent>`. HTTP error codes map to typed exceptions. Provider is generated for dependency injection.
  </done>
</task>

</tasks>

<verification>
1. All files in `lib/features/chat/domain/` and `lib/features/chat/data/` compile without errors.
2. `fvm flutter analyze` passes with no new errors or warnings.
3. `fvm dart run build_runner build --delete-conflicting-outputs` generates all expected `.freezed.dart` and `.g.dart` files.
4. ChatEvent.fromJson can parse all 6 event types matching the server protocol in `streamHandler.ts`.
5. ChatRepository provider is generated and injectable via Riverpod.
</verification>

<success_criteria>
- ChatEvent sealed class with 6 union variants (step, textDelta, responseId, conversionId, error, done) compiles and deserializes from JSON
- ChatStreamState Freezed class with all lifecycle fields compiles
- ChatException hierarchy with 5 concrete exception types compiles
- SseEventTransformer handles chunk splitting by buffering on \n\n boundaries
- ChatRepository.sendQuestion() returns Stream<ChatEvent> via supabase_flutter SSE
- HTTP 401/403/429 map to ChatAuthException/ChatPremiumRequiredException/ChatRateLimitException
- `fvm flutter analyze` passes clean
</success_criteria>

<output>
After completion, create `.planning/phases/02-stream-client/02-01-SUMMARY.md`
</output>
