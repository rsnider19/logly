import 'package:logly/core/providers/logger_provider.dart';
import 'package:logly/core/services/logger_service.dart';
import 'package:logly/features/home/data/daily_activities_repository.dart';
import 'package:logly/features/home/data/trending_repository.dart';
import 'package:logly/features/home/domain/daily_activity_summary.dart';
import 'package:logly/features/home/domain/trending_activity.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'home_service.g.dart';

/// Service for coordinating home screen operations.
///
/// Handles business logic for daily activities and trending data.
class HomeService {
  HomeService(this._dailyActivitiesRepository, this._trendingRepository, this._logger);

  final DailyActivitiesRepository _dailyActivitiesRepository;
  final TrendingRepository _trendingRepository;
  final LoggerService _logger;

  /// Fetches daily activity summaries for a date range.
  ///
  /// Returns summaries for days that have activities. Empty days
  /// should be generated by the UI layer.
  Future<List<DailyActivitySummary>> getDailyActivities({
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    if (endDate.isBefore(startDate)) {
      _logger.w('End date $endDate is before start date $startDate, swapping');
      final temp = startDate;
      startDate = endDate;
      endDate = temp;
    }

    _logger.d('Fetching daily activities from $startDate to $endDate');
    return _dailyActivitiesRepository.getByDateRange(startDate, endDate);
  }

  /// Fetches trending activities globally.
  Future<List<TrendingActivity>> getTrendingActivities({int limit = 25}) async {
    _logger.d('Fetching top $limit trending activities');
    return _trendingRepository.getTrending(limit: limit);
  }

  /// Generates a complete date range with empty days filled in.
  ///
  /// Takes the summaries from the database and fills in missing days
  /// with empty summaries.
  List<DailyActivitySummary> fillDateRange({
    required DateTime startDate,
    required DateTime endDate,
    required List<DailyActivitySummary> summaries,
  }) {
    final summaryMap = <DateTime, DailyActivitySummary>{};

    // Index existing summaries by date (normalized to midnight)
    for (final summary in summaries) {
      final normalizedDate = DateTime(
        summary.activityDate.year,
        summary.activityDate.month,
        summary.activityDate.day,
      );
      summaryMap[normalizedDate] = summary;
    }

    // Generate complete list
    final result = <DailyActivitySummary>[];
    var current = DateTime(startDate.year, startDate.month, startDate.day);
    final end = DateTime(endDate.year, endDate.month, endDate.day);

    while (!current.isAfter(end)) {
      final summary = summaryMap[current];
      if (summary != null) {
        result.add(summary);
      } else {
        result.add(DailyActivitySummary(
          activityDate: current,
          activityCount: 0,
        ));
      }
      current = current.add(const Duration(days: 1));
    }

    // Sort by date descending (most recent first)
    result.sort((a, b) => b.activityDate.compareTo(a.activityDate));

    return result;
  }
}

/// Provides the home service instance.
@Riverpod(keepAlive: true)
HomeService homeService(Ref ref) {
  return HomeService(
    ref.watch(dailyActivitiesRepositoryProvider),
    ref.watch(trendingRepositoryProvider),
    ref.watch(loggerProvider),
  );
}
