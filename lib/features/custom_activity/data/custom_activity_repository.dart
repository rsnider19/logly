import 'package:logly/core/providers/logger_provider.dart';
import 'package:logly/core/providers/supabase_provider.dart';
import 'package:logly/core/services/logger_service.dart';
import 'package:logly/features/activity_catalog/domain/activity.dart';
import 'package:logly/features/activity_catalog/domain/imperial_uom.dart';
import 'package:logly/features/activity_catalog/domain/metric_uom.dart';
import 'package:logly/features/custom_activity/domain/activity_detail_config.dart';
import 'package:logly/features/custom_activity/domain/custom_activity_exception.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

part 'custom_activity_repository.g.dart';

/// Repository for creating custom activities via Supabase.
class CustomActivityRepository {
  CustomActivityRepository(this._supabase, this._logger);

  final SupabaseClient _supabase;
  final LoggerService _logger;

  /// Checks if the given activity name is unique for the current user.
  ///
  /// The check is case-insensitive.
  Future<bool> isNameUnique(String name) async {
    try {
      final existing = await _supabase
          .from('activity')
          .select('activity_id')
          .neq('created_by', '00000000-0000-0000-0000-000000000000')
          .ilike('name', name)
          .maybeSingle();

      return existing == null;
    } catch (e, st) {
      _logger.e('Failed to check activity name uniqueness', e, st);
      throw CheckActivityNameException(e.toString());
    }
  }

  /// Creates a custom activity with the given details.
  ///
  /// Returns the created [Activity] with all nested data.
  Future<Activity> createCustomActivity({
    required String categoryId,
    required String name,
    required List<ActivityDetailConfig> details,
  }) async {
    try {
      // Determine pace type from details
      final paceDetail = details.whereType<PaceDetailConfig>().firstOrNull;
      final paceType = paceDetail?.paceType;

      // Insert activity
      final activityResponse = await _supabase
          .from('activity')
          .insert({
            'activity_category_id': categoryId,
            'name': name,
            'activity_code': '', // Will be generated by trigger
            'activity_date_type': 'single',
            'pace_type': paceType?.name,
          })
          .select('*, activity_category:activity_category(*)')
          .single();

      final activityId = activityResponse['activity_id'] as String;

      // Insert activity details
      if (details.isNotEmpty) {
        final detailRecords = <Map<String, dynamic>>[];

        for (var i = 0; i < details.length; i++) {
          final detail = details[i];
          final record = _buildDetailRecord(activityId, detail, i * 10);
          if (record != null) {
            detailRecords.add(record);
          }
        }

        if (detailRecords.isNotEmpty) {
          await _supabase.from('activity_detail').insert(detailRecords);
        }
      }

      // Fetch complete activity with details
      final completeResponse = await _supabase
          .from('activity')
          .select('*, activity_category:activity_category(*), activity_detail:activity_detail(*)')
          .eq('activity_id', activityId)
          .single();

      return Activity.fromJson(completeResponse);
    } catch (e, st) {
      _logger.e('Failed to create custom activity', e, st);
      if (e is CustomActivityException) rethrow;
      throw CreateCustomActivityException(e.toString());
    }
  }

  /// Builds a detail record for insertion into activity_detail table.
  Map<String, dynamic>? _buildDetailRecord(String activityId, ActivityDetailConfig config, int sortOrder) {
    return switch (config) {
      NumberDetailConfig(:final label, :final isInteger, :final maxValue) => {
          'activity_id': activityId,
          'label': label,
          'activity_detail_type': isInteger ? 'integer' : 'double',
          'sort_order': sortOrder,
          'min_numeric': 0,
          'max_numeric': maxValue,
          'slider_interval': isInteger ? 1 : 0.1,
        },
      DurationDetailConfig(:final label, :final maxSeconds, :final useForPace) => {
          'activity_id': activityId,
          'label': label,
          'activity_detail_type': 'duration',
          'sort_order': sortOrder,
          'min_duration_in_sec': 0,
          'max_duration_in_sec': maxSeconds,
          'slider_interval': 60,
          'use_for_pace_calculation': useForPace,
        },
      DistanceDetailConfig(:final label, :final isShort, :final maxValue, :final useForPace) => {
          'activity_id': activityId,
          'label': label,
          'activity_detail_type': 'distance',
          'sort_order': sortOrder,
          'min_distance_in_meters': 0,
          'max_distance_in_meters': isShort ? maxValue : maxValue * 1000,
          'slider_interval': 0.1,
          'metric_uom': isShort ? MetricUom.meters.name : MetricUom.kilometers.name,
          'imperial_uom': isShort ? ImperialUom.yards.name : ImperialUom.miles.name,
          'use_for_pace_calculation': useForPace,
        },
      EnvironmentDetailConfig(:final label) => {
          'activity_id': activityId,
          'label': label.isEmpty ? 'Environment' : label,
          'activity_detail_type': 'environment',
          'sort_order': sortOrder,
        },
      PaceDetailConfig() => null, // Pace is stored on activity, not as a detail
    };
  }
}

/// Provides the custom activity repository instance.
@Riverpod(keepAlive: true)
CustomActivityRepository customActivityRepository(Ref ref) {
  return CustomActivityRepository(
    ref.watch(supabaseProvider),
    ref.watch(loggerProvider),
  );
}
